<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="__CSP__">
    <title>Interactive code explorer</title>
    <script nonce="__NONCE__" src="https://d3js.org/d3.v7.min.js"></script>
    
    <script nonce="__NONCE__" src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style nonce="__NONCE__">
            :root {
            --font-family: system-ui, -apple-system, sans-serif;
            --color-bg: #FFFFFF;
            --color-text: #333;
            --color-border-soft: #E0E0E0;
            --color-shadow: rgba(0, 0, 0, 0.07);
            --edge-color: #BDBDBD;
            --edge-color-highlight: #FFA726;

            --pill-method-bg: #FBE9A8;
            --pill-method-text: #5A4803;
            --pill-field-bg: #A8D1FB;
            --pill-field-text: #033E6B;
            --pill-primitive-bg: #EFEFEF;
            --pill-primitive-text: #424242;
            --overview-badge-bg: #BDBDBD;
            --overview-badge-text: #FFFFFF;

            --coupling-color-afferent: #FFA726;  
            --coupling-color-efferent: #AB47BC; 
            --coupling-color-god: #E53935;      
            --coupling-color-health: #4CAF50;
        }

        body { font-family: var(--font-family); background-color: var(--color-bg); margin: 0; overflow: hidden; }
        #app-container { display: flex; flex-direction: column; height: 100vh; }
        #header { padding: 8px 12px; background: #fff; border-bottom: 1px solid var(--color-border-soft); flex-shrink: 0; }
        #diagram-container { flex: 1; position: relative; overflow: hidden; }
        svg#diagram { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: grab; }
        svg#diagram:active { cursor: grabbing; }

        .breadcrumb { font-size: 14px; padding: 4px 8px; }
        .breadcrumb a { color: #007bff; text-decoration: none; cursor: pointer; }
        .breadcrumb a:hover { text-decoration: underline; }
        .breadcrumb span { margin: 0 5px; color: #6c757d; }
        .breadcrumb .current { font-weight: 600; color: #343a40; cursor: default; }
        #tooltip { background: #333; color: white; padding: 6px 10px; border-radius: 4px; font-size: 12px; pointer-events: none; opacity: 0; z-index: 10; transition: opacity 0.2s; position: absolute; visibility: hidden; }
        #tooltip.visible { visibility: visible; opacity: 1; }

        .detailed-edge {
            stroke: #B0B0B0;
            stroke-width: 1.5px;
            stroke-dasharray: 3, 3;
        }

        .graph-unfocused .node:not(.highlight),
        .graph-unfocused .edge-path:not(.highlight) { opacity: 0.15; transition: opacity 0.2s ease-in-out; }
        .highlight { opacity: 1 !important; }

        .edge-path {
            fill: none;
            stroke-width: 1.5px;
            transition: stroke 0.2s ease-in-out, opacity 0.2s ease-in-out;
        }

        .edge-path.default-edge-color {
            stroke: #adb5bd; 
        }

        .edge-path.calls { stroke: #6f42c1; }
        .edge-path.extends { stroke: #28a744; }
        .edge-path.implements { stroke: #17a2b8; }
        .edge-path.reads-from { stroke: #fd7e14; }
        .edge-path.writes-to { stroke: #dc3545; }
        .edge-path.instance-of { stroke: #007bff; }
        .edge-path.uses-as-type { stroke: #6c757d; }
        .edge-path.unknown { stroke: #adb5bd; }

        .edge-path.hidden {
            display: none;
        }


        .edge-path.visible {
            display: block;
        }

        .main-layer {
            transition: opacity 0.3s ease-in-out;
        }

        .main-layer.graph-unfocused > g > .node,
        .main-layer.graph-unfocused > g > .edge-layer > .aggregated-edge-group > .edge-path,
        .main-layer.graph-unfocused > g > .edge-layer > .edge-path {
            opacity: 0.15; 
        }

        .node.highlight,
        .edge-path.highlight {
            opacity: 1 !important;
            stroke-width: 3px;
        }
        

        .aggregated-edge {
            stroke: #888;
            stroke-width: 2.5px;
        }


        .overview-item { cursor: pointer; }
        .overview-item:hover .item-rect { filter: drop-shadow(0px 4px 8px rgba(0,0,0,0.1)); stroke: #AAB; }
        .overview-item .item-rect { rx: 8px; ry: 8px; filter: drop-shadow(0px 2px 5px var(--color-shadow)); stroke-width: 1px; }
        .overview-item.color-default .item-rect { fill: var(--pill-primitive-bg); stroke: var(--color-border-soft); }
        .overview-item.color-functions .item-rect { fill: var(--pill-method-bg); stroke: #FBC02D; }
        .overview-item .item-icon { font-size: 16px; fill: #616161; dominant-baseline: middle; }
        .overview-item .item-label { font-size: 14px; font-weight: 500; fill: var(--color-text); dominant-baseline: middle; }
        .overview-item .item-badge-bg { fill: var(--overview-badge-bg); }
        .overview-item .item-badge-text { fill: var(--overview-badge-text); font-size: 11px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; }

        .overview-item.color-view .item-rect { fill: #E3F2FD; stroke: #90CAF9; }
        .overview-item.color-state .item-rect { fill: #FFFDE7; stroke: #FFF59D; }
        .overview-item.color-service .item-rect { fill: #E8F5E9; stroke: #A5D6A7; }
        .overview-item.color-model .item-rect { fill: #FBE9E7; stroke: #FFAB91; }
        .overview-item.color-utility .item-rect { fill: #F5F5F5; stroke: #E0E0E0; }

        .overview-item.color-member .item-rect, 
        .overview-item:not([class*='color-']) .item-rect {
            fill: #2e7d32; ; 
            stroke: #a5d6a7; 
        }

        .overview-item.color-member .item-label, 
        .overview-item:not([class*='color-']) .item-label,
        .overview-item.color-member .item-icon, 
        .overview-item:not([class*='color-']) .item-icon {
            fill: #FFFFFF;
        }

        .list-view-header { font-size: 22px; font-weight: 300; fill: #616161; }
        
        .node-container-class .node-rect { fill: #FAFAFA; stroke: var(--color-border-soft); stroke-width: 1.5px; rx: 12px; filter: drop-shadow(0px 4px 10px var(--color-shadow)); }
        .node-container-class .class-header { font-size: 14px; font-weight: 600; dominant-baseline: middle; }
        .node-container-class .member-icon { cursor: pointer; }
        .node-container-class .section-divider { stroke: var(--color-border-soft); stroke-width: 1px; stroke-dasharray: 2, 2; }
        
        .pill { cursor: pointer; }
        .pill .pill-rect { rx: 14px; ry: 14px; transition: transform 0.15s ease; stroke: none; }
        .pill .pill-label { font-size: 12px; text-anchor: middle; dominant-baseline: middle; }
        .pill:hover .pill-rect { transform: scale(1.05); }

        .pill-primitive .pill-rect { fill: var(--pill-primitive-bg); }
        .pill-primitive .pill-label { fill: var(--pill-primitive-text); }
        .pill-method .pill-rect { fill: var(--pill-method-bg); }
        .pill-method .pill-label { fill: var(--pill-method-text); }
        .pill-field .pill-rect { fill: var(--pill-field-bg); }
        .pill-field .pill-label { fill: var(--pill-field-text); }

        .coupling-indicator { 
            fill: #FFFFFF; 
            stroke-width: 2.5px;  
        }
        .indicator-afferent-high { fill: var(--coupling-color-afferent); stroke: #C77700; }
        .indicator-efferent-high { fill: var(--coupling-color-efferent); stroke: #7B1FA2; }
        .indicator-god-object { fill: var(--coupling-color-god); stroke: #9A0007; }
        .indicator-healthy { 
            fill: var(--coupling-color-health);
            stroke: #388E3C;
            stroke-width: 1px;
        }

        .pill.coupling-high .pill-rect { stroke: var(--coupling-color-afferent); stroke-width: 2.5px; }
        .pill.coupling-critical .pill-rect { stroke: var(--coupling-color-god); stroke-width: 2.5px; }

        .context-menu {
            position: absolute;
            visibility: hidden; 
            background-color: #FAFAFA;
            border: 1px solid var(--color-border-soft, #E0E0E0);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 6px 0;
            z-index: 20;
            min-width: 180px;
            font-family: var(--font-family);
        }

        .context-menu.visible {
            visibility: visible;
        }

        .context-menu-item {
            padding: 8px 16px;
            font-size: 13px;
            color: var(--color-text);
            cursor: pointer;
            white-space: nowrap; 
        }

        .context-menu-item:hover {
            background-color: #007bff;
            color: white;
        }

        #relationship-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            
            background-color: #ffffff;
            border-top: 1px solid #e1e1e1;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
            color: #333;

            padding: 16px;
            font-family: var(--vscode-font-family, system-ui, sans-serif);
            font-size: 14px;
            max-height: 200px;
            overflow-y: auto;
            
            opacity: 0;
            transform: translateY(100%);
            transition: opacity 300ms ease-in-out, transform 300ms ease-in-out;
            z-index: 100;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px; 
        }

        #relationship-panel.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .rel-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            width: 100%;
            max-width: 800px;
        }

        .rel-node {
            background-color: #f0f0f0;
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid #dcdcdc;
            font-weight: 500;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .rel-card {
            background-color: #f8f9fa;
            border: 1px solid #e1e1e1;
            border-radius: 8px;
            padding: 12px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }

        .rel-verb {
            display: flex;
            align-items: center;
            text-align: center;
            flex-grow: 1;
            justify-content: center;
            font-style: italic;
            white-space: nowrap;
        }

        .rel-verb .rel-arrow {
            font-size: 16px;
            color: #999;
            margin: 0 8px;
        }
        

        hr.rel-divider {
            border: none;
            border-top: 1px solid #eee;
            margin: 10px 0;
        }

        .rel-verbs-list ul {
            margin: 0;
            padding-left: 20px;
            list-style: none;
        }

        .rel-verbs-list li {
            padding: 2px 0;
        }
        .rel-verbs-list li::before {
            content: '‚Ä¢';
            margin-right: 8px;
            color: #999;
        }

        #relationship-panel h4 {
            display: none;
        }

        .rel-text-extends { color: #28a745; }
        .rel-text-implements { color: #17a2b8; }
        .rel-text-calls { color: #6f42c1; font-weight: bold; }
        .rel-text-reads-from { color: #fd7e14; }
        .rel-text-writes-to { color: #dc3545; }
        .rel-text-instance-of { color: #007bff; }
        .rel-text-uses-as-type { color: #6c757d; }
        .rel-text-unknown { color: #adb5bd; }

        #list-view-container {
            height: 100%;
            overflow-y: auto;
            padding: 20px 40px;
            box-sizing: border-box;
            background-color: #ffffff; 
            color: #212121; 
        }

        .search-container {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #f0f0f0; 
        }

        .search-input {
            width: 100%;
            padding: 10px 14px;
            font-size: 16px;
            border-radius: 6px;
            border: 1px solid #dcdcdc;
            background-color: #f5f5f5; 
            color: #212121;
        }

        .search-input::placeholder {
            color: #888888;
        }

        .search-input:focus {
            outline: none;
            border-color: #6f42c1;
            box-shadow: 0 0 0 1px #6f42c1;
        }

        .list-view-header {
            font-size: 20px;
            font-weight: 600;
            color: #444444;
            margin-top: 20px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #eeeeee;
        }

        .list-view-item {
            display: flex;
            justify-content: space-between; 
            align-items: center;
            padding: 9px 12px;
            margin-bottom: 2px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out, color 0.1s ease-in-out;
            font-size: 14px;
            color: #333333;
        }

        .item-label {
            margin-right: 16px;
        }

        .item-indicators {
            display: flex;
            gap: 12px; 
            font-size: 12px;
            font-weight: 500;
            flex-shrink: 0; 
        }

        .item-indicators .indicator-in {
            color: var(--coupling-color-afferent, #FFA726); 
        }
        .item-indicators .indicator-out {
            color: var(--coupling-color-efferent, #AB47BC);
        }

        .list-view-item:hover .item-indicators,
        .list-view-item:hover .item-indicators span {
            color: #ffffff;
        }

        .list-view-item.importance-high {
            font-weight: 600; 
            font-size: 15px;
            color: var(--color-text, #212121);
        }
        .list-view-item.importance-medium {
            font-weight: 400;
            font-size: 14px;
            color: var(--color-text, #333333);
        }
        .list-view-item.importance-low {
            font-size: 13px;
            color: #757575;
            opacity: 0.9;
        }

        .list-view-item:hover {
            transform: translateX(5px);
            background-color: #6f42c1;
            color: #ffffff !important;
            opacity: 1;
        }

        .pill.focused-member .pill-rect {
            stroke: var(--vscode-focusBorder, #007fd4);
            stroke-width: 2.5px;
        }

        .back-button-overlay {
            position: absolute;
            bottom: 25px;
            left: 25px;
            z-index: 10;

            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 8px 16px;
            border-radius: 20px; 
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            backdrop-filter: blur(4px); 
            
            display: flex;
            align-items: center;
            gap: 6px; 
            
            transition: all 0.2s ease-in-out;
        }

        .back-button-overlay:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        .back-button-overlay.disabled {
            opacity: 0;
            pointer-events: none; 
            transform: translateY(10px);
        }

        .node.is-main-focus > .node-rect,
        .node.is-main-focus > .pill .pill-rect {
            stroke: var(--vscode-focusBorder, #007BEA);
            stroke-width: 3px;
            stroke-dasharray: none; 
        }

        .node.trace-active > .node-rect,
        .node.trace-active > .pill .pill-rect {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                stroke: var(--coupling-color-god, #E53935);
                stroke-width: 4px;
            }
            50% {
                stroke: var(--coupling-color-afferent, #FFA726);
                stroke-width: 6px;
            }
            100% {
                stroke: var(--coupling-color-god, #E53935);
                stroke-width: 4px;
            }
        }

        .node-container-class.color-view .node-rect { fill: #E3F2FD; stroke: #90CAF9; }
        .node-container-class.color-state .node-rect { fill: #FFFDE7; stroke: #FFF59D; }
        .node-container-class.color-service .node-rect { fill: #E8F5E9; stroke: #A5D6A7; }
        .node-container-class.color-model .node-rect { fill: #FBE9E7; stroke: #FFAB91; }
        .node-container-class.color-utility .node-rect { fill: #F5F5F5; stroke: #E0E0E0; }

        .edge-virtual.edge-path {
            stroke: #8FCB9B !important;
            stroke-dasharray: 4;
            opacity: 0.6;
        }

        .pill-collapsed-member .pill-rect {
            fill: #fdd835; 
            stroke: #f9a825;
            stroke-width: 1.5;
        }

        .pill-collapsed-member .pill-label {
            fill: #212121;
            font-weight: bold;
        }

        .overview-item.color-external_packages .item-rect { 
            fill: #1E3A8A; 
            stroke: #3B82F6; 
        }

        .overview-item.color-external_packages .item-label, 
        .overview-item.color-external_packages .item-icon {
            fill: #FFFFFF; 
        }

        .overview-item.color-custom_packages .item-rect { 
            fill: #06B6D4; 
            stroke: #0891B2; 
        }

        .overview-item.color-custom_packages .item-label, 
        .overview-item.color-custom_packages .item-icon {
            fill: #FFFFFF;
        }

        .pill-external-package .pill-rect {
            fill: #DBEAFE; 
            stroke: #3B82F6;
            stroke-width: 2px;
        }

        .pill-external-package .pill-label {
            fill: #1E40AF; 
            font-weight: 600;
        }

        .pill-custom-package .pill-rect {
            fill: #D1FAE5;
            stroke: #059669;
            stroke-width: 2px;
        }

        .pill-custom-package .pill-label {
            fill: #047857;
            font-weight: 600;
        }


        #layer-navigation-slider {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 15;
            
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            border-radius: 16px;
            padding: 16px 20px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
            transition: all 0.3s ease-in-out;
            
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 280px;
        }

        #layer-navigation-slider.visible {
            opacity: 1;
            pointer-events: all;
            transform: translateY(0);
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-track {
            position: relative;
            height: 6px;
            background: linear-gradient(90deg, 
                #E3F2FD 0% 20%,     
                #FFFDE7 20% 40%,   
                #E8F5E9 40% 60%,    
                #FBE9E7 60% 80%,    
                #F5F5F5 80% 100%    
            );
            border-radius: 3px;
            cursor: pointer;
        }

        .slider-thumb {
            position: absolute;
            top: -6px;
            left: 0%;
            width: 18px;
            height: 18px;
            background: #ffffff;
            border: 3px solid #6f42c1;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: left 0.2s ease;
            transform: translateX(-50%);
            user-select: none; 
        }

        .slider-thumb:hover {
            transform: translateX(-50%) scale(1.2);
            border-color: #5a2d91;
        }

        .slider-thumb:active,
        .slider-thumb.dragging {
            cursor: grabbing;
            transform: translateX(-50%) scale(1.1);
            transition: none; 
        }

        .layer-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            font-weight: 500;
            margin-top: 4px;
        }

        .layer-label {
            color: #666;
            text-align: center;
            flex: 1;
            cursor: pointer;
            padding: 4px 2px;
            border-radius: 4px;
            transition: all 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            user-select: none; 
        }

        .layer-label:hover {
            background: rgba(111, 66, 193, 0.1);
            color: #6f42c1;
        }

        .layer-label.active {
            background: #6f42c1;
            color: white;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            #layer-navigation-slider {
                min-width: 240px;
                padding: 12px 16px;
                right: 10px;
            }
            
            .layer-label {
                font-size: 10px;
            }
        }

        .pill-folder-center .pill-rect {
            fill: #4A5568; 
            stroke: #A0AEC0;
            stroke-width: 1.5px;
        }

        .pill-folder-center .pill-label {
            fill: #FFFFFF; 
            font-weight: bold;
            font-size: 13px;
        }

        #tooltip { position: absolute; visibility: hidden; background: #212529; color: white; padding: 6px 10px; border-radius: 4px; font-size: 12px; pointer-events: none; opacity: 0; z-index: 10; transition: opacity 0.2s; }
        #tooltip.visible { visibility: visible; opacity: 1; }
    </style>
</head>
<body>
  <div id="app-container">
    <div id="header"><div id="breadcrumb" class="breadcrumb"></div></div>
    <div id="diagram-container">
        <svg id="diagram"></svg>
         <a href="#" id="back-button-overlay" class="back-button-overlay disabled" data-text="button.back">‚Üê Back to previous object</a>
    </div>
    <div id="list-view-container" style="display: none;"></div>
  </div>
  
  <div id="tooltip"></div>
  <div id="context-menu" class="context-menu">
    <div class="context-menu-item" id="trace-flow-btn" data-text="context.traceFlow">Trazar Flujo de Datos</div>
    </div>

    <div id="relationship-panel"></div>

    <div id="layer-navigation-slider" class="layer-slider">
        <div class="slider-container">
            <div class="slider-track">
                <div class="slider-thumb" id="slider-thumb"></div>
            </div>
            <div class="layer-labels">
                <span class="layer-label" data-layer="view" data-text="layer.view">üì± Vistas</span>
                <span class="layer-label" data-layer="state" data-text="layer.state">üß† Estado</span>
                <span class="layer-label" data-layer="service" data-text="layer.service">üåê Servicios</span>
                <span class="layer-label" data-layer="model" data-text="layer.model">üì¶ Modelos</span>
                <span class="layer-label" data-layer="utility" data-text="layer.utility">üõ†Ô∏è Utilidades</span>
            </div>
        </div>
    </div>

  <script nonce="__NONCE__">

    const translations = __TRANSLATIONS__;
    
    function t(key, ...args) {
        let translation = translations[key] || key;
        
        args.forEach((arg, index) => {
            translation = translation.replace(`{${index}}`, arg);
        });
        
        return translation;
    }

    function initializeTranslations() {
        const backButton = document.getElementById('back-button-overlay');
        if (backButton) {
            backButton.innerHTML = `‚Üê ${t('button.back')}`;
        }
        
        const traceFlowBtn = document.getElementById('trace-flow-btn');
        if (traceFlowBtn) {
            traceFlowBtn.textContent = t('context.traceFlow');
        }
        
        document.querySelectorAll('.layer-label').forEach(label => {
            const textKey = label.dataset.text;
            if (textKey) {
                const icon = label.textContent.split(' ')[0];
                label.innerHTML = `${icon} ${t(textKey)}`;
            }
        });
    }

    (function main() {
        let vscodeApi;
        try {
            vscodeApi = acquireVsCodeApi();
        } catch (e) {
            vscodeApi = { postMessage: (msg) => console.log("VSCode Mock:", msg) };
        }

        let allGraphNodes = [];
        let allGraphEdges = [];
        let nodeMap = new Map();
        let historyStack = [];
        let focusedContainerId = null;
        let pinnedRelationshipData = null;
        let expandedGroupIds = new Set(); 
        let folderDrill = null; 
        let DEBUG_FIT = false;
        let lastFocusData = null; 
        const FOLDERS_DISABLED = true;

        let folderContentIndex = new Map();

        let currentLayerIndex = 0;
        let folderLevels = null;
        let currentFolderLevel = 0;
        let isDragging = false;
        const layerOrder = ['view', 'state', 'service', 'model', 'utility'];


        window.addEventListener('message', event => {
            const message = event.data; 
            switch (message.command) {
                case 'setFocusInGraph':
                   if (message.nodeId && nodeMap.has(message.nodeId)) {
                        vscodeApi.postMessage({ command: 'log', args: [`[WebView] Received focus for: ${message.nodeId}`]});
                        pushRoute(message.nodeId);
                        render();
                    }
                    break;
                case 'displayImports':
                    if (message.nodeId && message.imports) {
                        finishRenderingFocusView(message.nodeId, message.imports);
                    }
                    break;
                case 'setPathHighlight':
                    if (message.sourceId && message.targetId) {
                        highlightPath(message.sourceId, message.targetId);
                    }
                    break;

                case 'displayDataFlow':
                    if (message.path) {
                        animateDataFlow(message.path);
                    }
                    break;
            }
        });

        try {
            const rawData = `__AST_JSON_PLACEHOLDER__`;
            const receivedData = JSON.parse(rawData);
            vscodeApi.postMessage({ command: 'log', args: [`This is the extension: ${receivedData.graph.nodes.length}`] });
            
            if (receivedData && receivedData.graph) {
                allGraphNodes = receivedData.graph.nodes || [];
                allGraphEdges = receivedData.graph.edges || [];
                nodeMap = new Map(allGraphNodes.map(n => [n.id, n]));
                vscodeApi.postMessage({ command: 'log', args: [`[WebView] Real Graph received. Nodes: ${allGraphNodes.length}, Edges: ${allGraphEdges.length}`]});
                folderContentIndex = buildFolderContentIndex();
            } else {
                throw new Error("The received data structure is invalid.");
            }
        } catch (e) {
             vscodeApi.postMessage({ command: 'log', args: [`Error processing data from the extension, using test data.`, e.message] });
            
            // --- TEST DATA (ONLY IF THE PLACEHOLDER FAILS)---
            allGraphNodes = [
                { id: 'main', label: 'main', kind: 'entry', file: 'main.dart' },
                { id: 'tictactoe_class', label: 'TicTacToe', kind: 'class', file: 'tictactoe.dart', isCollapsed: false },
                { id: 'tictactoe_run', label: '‚ñ∂ Run', kind: 'method', parent: 'tictactoe_class' },
                { id: 'tictactoe_players', label: 'players', kind: 'field', parent: 'tictactoe_class' },
                { id: 'tictactoe_field', label: 'field', kind: 'field', parent: 'tictactoe_class' },
                { id: 'field_class', label: 'Field', kind: 'class', file: 'field.dart', isCollapsed: false},
                { id: 'show_method', label: 'Show', kind: 'method', parent: 'field_class' },
                { id: 'player_class', label: 'Player', kind: 'class', file: 'player.dart', isCollapsed: false },
                { id: 'turn_method', label: 'Turn', kind: 'method', parent: 'player_class' },
                { id: 'int_type', label: 'Int', kind: 'type', file: 'dart:core' },
            ];
            allGraphEdges = [
                { id: 'e1', source: 'main', target: 'tictactoe_run', label: 'CALLS' },
                { id: 'e2', source: 'tictactoe_run', target: 'show_method', label: 'CALLS' },
                { id: 'e3', source: 'tictactoe_run', target: 'turn_method', label: 'CALLS' },
                { id: 'e4', source: 'tictactoe_field', target: 'int_type', label: 'USES_AS_TYPE' },
                { id: 'e5', source: 'tictactoe_players', target: 'player_class', label: 'INSTANCE_OF' },
            ];    
        }

        
        const svg = document.getElementById('diagram');
        const backButton = document.getElementById('back-button-overlay');
        const mainLayer = createSvgElement('g', { class: 'main-layer' });
        const edgeLayer = createSvgElement('g', { class: 'edge-layer' });
        const nodeLayer = createSvgElement('g', { class: 'node-layer' });
        const tooltip = document.getElementById('tooltip');
        const relationshipPanel = document.getElementById('relationship-panel');
    
        svg.appendChild(mainLayer);

        const contextMenu = document.getElementById('context-menu');
        const traceFlowBtn = document.getElementById('trace-flow-btn');
        const foldersBtn = document.getElementById('folders-button');       
        const backToObjectBtn = document.getElementById('back-to-object'); 
        
        if (foldersBtn) {
         foldersBtn.style.display = 'none';
        }
        
        window.addEventListener('click', () => contextMenu.classList.remove('visible'));
        traceFlowBtn.addEventListener('click', () => {
            try{
                const nodeId = contextMenu.dataset.nodeId;
                vscodeApi.postMessage({ command: 'log', args: [`[WebView] Requesting data flow trace for: ${nodeId}`] });
                vscodeApi.postMessage({
                    command: 'traceDataFlow',
                    startNodeId: nodeId
                });
            }catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [
                        `[WebView-ERROR] Critical failure in tracefullDataImpact: ${e.message}`,
                        `Stack: ${e.stack}`
                    ]
                });
                
            }
        });


        setupMarkers(svg);
        const zoom = setupZoomPan(svg, mainLayer);

        backButton.addEventListener('click', goBack);

        render(); 

        initializeTranslations();
        
        /**
         * Main rendering function that handles the display of different application states.
         * Manages navigation between views (overview, list, folders, focus) and updates the interface according
         * to the current state of the navigation history. Clears previous visual elements, determines the current
         * state based on the history, and renders the appropriate view while managing relationships between
         * nodes and communication with VS Code.
         *
         * States handled:
         * - 'overview': General view of the diagram
         * - 'overview-list': General list view
         * - 'folders': Folder diagram view
         * - 'folder-list': Specific folder list view
         * - Default state: Focus view on a specific node
         *
         * @throws {Error} If the required context node is not found
         */
        function render() {
            try {
                const diagramContainer = document.getElementById('diagram-container');
                const listContainer = document.getElementById('list-view-container');

                mainLayer.classList.remove('graph-unfocused');
                mainLayer.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
                tooltip.classList.remove('visible');

                const historyDepth = historyStack.length;
                const currentId = historyDepth > 0 ? historyStack[historyStack.length - 1] : 'overview';
                const state = getRouteState(currentId);

                applyNavUI(state);

                if (state === 'overview') {
                    listContainer.style.display = 'none';
                    diagramContainer.style.display = 'block';
                    pinnedRelationshipData = null;
                    vscodeApi.postMessage({ command: 'clearRelationships' });
                    renderOverview();
                    hideLayerSlider();
                    hideBackToOverviewButton();

                } else if (state === 'overview-list') {
                    pinnedRelationshipData = null;
                    vscodeApi.postMessage({ command: 'clearRelationships' });
                    renderListView(currentId.split('-')[1])
                    hideLayerSlider();;

                } else if (state === 'folders') {
                    pinnedRelationshipData = null;
                    vscodeApi.postMessage({ command: 'clearRelationships' });

                    listContainer.style.display = 'none';
                    diagramContainer.style.display = 'block';

                    const base = currentId.substring('folders:'.length);
                    const pathParts = base === '.' ? [] : base.split('/');
                    renderFolderDiagram(pathParts);
                    hideBackToOverviewButton();

                } else if (state === 'folder-list') {
                    pinnedRelationshipData = null;
                    vscodeApi.postMessage({ command: 'clearRelationships' });

                    listContainer.style.display = 'block';
                    diagramContainer.style.display = 'none';

                    const folderId = currentId.split(':')[1];
                    const folderName = folderId.replace(/^folder-/, '');

                    const nodesToList = allGraphNodes
                        .filter(n => !n.parent && ['class','enum','mixin'].includes(n.kind))
                        .filter(n => getFolderOfNode(n) === folderName);

                    listContainer.innerHTML = '';
                    const header = document.createElement('h2');
                    header.className = 'list-view-header';
                    header.textContent = t('folder.label', folderName);
                    listContainer.appendChild(header);

                    const listWrap = document.createElement('div');
                    listContainer.appendChild(listWrap);
                    displayFilteredList(nodesToList, listWrap);
                    hideBackToOverviewButton();

                } else { 
                    listContainer.style.display = 'none';
                    diagramContainer.style.display = 'block';
                    hideBackToOverviewButton();

                    const node = nodeMap.get(currentId);
                    if (node) {
                        const contextNodeId = node.parent || node.id;
                        const contextNode = nodeMap.get(contextNodeId);
                        const allConnectedEdges = findConnectedDetailedEdges(contextNodeId);
                        const uniqueConnectedEdges = getDeduplicatedRelationships(allConnectedEdges, nodeMap);
                        pinnedRelationshipData = uniqueConnectedEdges.map(edge => ({
                        ...edge,
                        sourceNode: nodeMap.get(getContainerId(edge.source)),
                        targetNode: nodeMap.get(getContainerId(edge.target))
                        }));

                        if (!contextNode) throw new Error(`contextNode not found for id: ${contextNodeId}`);

                        vscodeApi.postMessage({
                            command: 'showRelationships',
                            data: { focusedNodeLabel: contextNode.label, focusedNodeId: contextNode.id, edges: pinnedRelationshipData }
                        });

                        renderFocusView(contextNodeId, currentId);
                    } else {
                        historyStack = [];
                        render();
                    }
                }

                updateNavButtonsState();

            } catch (e) {
                vscodeApi.postMessage({ command: 'log',
                args: [`[WebView-ERROR] Critical failure in render: ${e.message}`, `Stack: ${e.stack}`]
                });
            }
        }


        const CONTAINER_KINDS = new Set([
        'class','enum','mixin','extension','typedef','primitive','widget','model'
        ]);

        /**
         * Determines if a node is a valid container. A node is considered a container if it has no parent,
         * belongs to specific container types (defined in CONTAINER_KINDS), or if it has a valid file URI
         * and is not an internal element like a method, function, constructor, etc.
         *
         * @param {Object} n - Node to evaluate
         * @returns {boolean} True if the node is a container
         */
        function isContainerNode(n){
            if (!n || n.parent) return false;
            if (CONTAINER_KINDS.has(n.kind)) return true;
            return n.data?.fileUri && !['method','function','constructor','field','property','member','group'].includes(n.kind);
        }

        /**
         * Gets all available detailed edges in the application. It searches multiple global sources
         * in order of priority: allGraphEdges, window.allDetailedEdges, window.allGraphEdges,
         * window.edges, returning an empty array if none are available.
         *
         * @returns {Array} Array of detailed edges or an empty array if none are found
        */
        function getAllDetailedEdges() {
            return (allGraphEdges && allGraphEdges.length) ? allGraphEdges
                : (window.allDetailedEdges || window.allGraphEdges || window.edges || []);
        }

        /**
         * Determines the route state based on the provided identifier. It analyzes the prefix
         * of the ID to classify it into different view types: overview, overview-list, folders,
         * folder-list, or focus as the default state.
         *
         * @param {string} id - Identifier of the current route
         * @returns {string} Route state ('overview', 'overview-list', 'folders', 'folder-list', 'focus')
        */
        function getRouteState(id){
            if (id === 'overview') return 'overview';
            if (id.startsWith('overview-')) return 'overview-list';
            if (id.startsWith('folders:')) return 'folders';
            if (id.startsWith('folder-list:')) return 'folder-list';
            return 'focus';
        }

        /**
         * Converts a node ID to its corresponding container ID. If the node has a parent,
         * it returns the parent's ID; otherwise, it returns the original ID.
         *
         * @param {string} id - Node ID to convert
         * @returns {string} The parent container's ID or the original ID
         */
        function toContainerId(id) {
            const n = nodeMap.get(id);
            return n?.parent || id;
        }


        function getRouteState(currentId){
            if (currentId === 'overview') return 'overview';
            if (currentId.startsWith('overview-')) return 'overview-list';
            if (currentId.startsWith('folders:')) return 'folders';
            if (currentId.startsWith('folder-list:')) return 'folder-list';
            return 'focus';
        }

        /**
         * Applies the navigation UI configuration according to the current state. Controls the
         * visibility of navigation buttons (back, folders, back to object) based
         * on the provided state.
         *
         * @param {string} state - Current application state
         */
        function applyNavUI(state){
            const show = (el, on) => { if (el) el.style.display = on ? 'inline-block' : 'none'; };
            switch (state){
                case 'overview':
                    show(backButton, false);
                    show(foldersBtn, true);
                    show(backToObjectBtn, false);
                    break;
                case 'overview-list':
                case 'folders':
                case 'folder-list':
                case 'focus':
                    show(backButton, true);
                    show(foldersBtn, false);
                    show(backToObjectBtn, false);
                    break;
            }
        }

        /**
         * Adds a new ID to the navigation history if it is not the same as the last element.
         * Prevents consecutive duplicates in the history stack.
         *
         * @param {string} id - The route ID to add to the history
         */
        function pushRoute(id){
            if (historyStack[historyStack.length - 1] !== id) {
                historyStack.push(id);
            }
        }

       /**
         * Navigates back in the route history. Removes the last element from the stack if there is
         * more than one, or resets to the overview if only one element remains. Clears expanded groups
         * and re-renders the view.
         */
        function goBack(){
            if (historyStack.length > 1) { 
                historyStack.pop();
            } else {
                historyStack = ['overview'];
            }
            expandedGroupIds.clear();
            render();
        }

        /**
         * Calculates and builds the folder graph for a specific path. Analyzes the folder
         * hierarchy, identifies container nodes, processes relationships between folders, and generates
         * the necessary nodes and edges for visualizing the folder diagram. Includes
         * processing metrics and logging for debugging.
         *
         * @param {Array<string>} pathParts - Array of parts of the current folder path
         * @returns {Object} Object with folderNodes and folderEdges for rendering
         */
        function computeFolderGraph(pathParts) {
            const currentKey = pathParts.join('/') || '.';

            const hierarchy = buildFolderHierarchyIndex(); 
            const nodeData = hierarchy.get(currentKey) || { folders:new Set(), files:new Set() };
            const folderKeys = Array.from(nodeData.folders).map(name => (currentKey === '.' ? name : `${currentKey}/${name}`));

            const folderNodes = folderKeys.map(k => ({
                id: `folder:${k}`,
                key: k,
                label: k.split('/').slice(-1)[0] || 'root',
                kind: 'group',
                layer: 'utility',
                nodes: []
            }));

            const containerNodes = allGraphNodes.filter(isContainerNode);
            const containerFolder = new Map();
            containerNodes.forEach(n => {
                const k = folderOfNodeAtLevel(n, currentKey);
                if (k != null) containerFolder.set(n.id, k);
            });

            const agg = new Map(); 
            const edges = getAllDetailedEdges();

            let cTotal = 0, cWithNodes = 0, cInScope = 0, cCrossChild = 0;

            const baseLen = (currentKey === '.' ? 0 : currentKey.split('/').length);
            const nextOf = (k) => {
                const parts = k.split('/');
                const child = parts[baseLen];
                return child ? ((currentKey === '.' ? '' : currentKey + '/') + child) : currentKey;
            };

            const inScope = (k) => (k === currentKey || k.startsWith(currentKey + '/'));

            function folderFromUriAtLevel(uri, currentKey) {
                if (!uri) return null;
                const parts = uri.split('/');
                const libIdx = parts.indexOf('lib');
                if (libIdx === -1) return null;
                const folderParts = parts.slice(libIdx, parts.length - 1);
                const base = currentKey === '.' ? [] : currentKey.split('/');
                for (let i = 0; i < base.length; i++) {
                    if (folderParts[i] !== base[i]) return null;
                }
                const child = folderParts[base.length];
                return child ? ((currentKey === '.' ? '' : currentKey + '/') + child) : (currentKey || '.');
            }

            edges.forEach(e => {
                cTotal++;

                const sId = (typeof getContainerId === 'function') ? getContainerId(e.source) : toContainerId(e.source);
                const tId = (typeof getContainerId === 'function') ? getContainerId(e.target) : toContainerId(e.target);

                const sNode = nodeMap.get(sId);
                const tNode = nodeMap.get(tId);
                if (!sNode || !tNode) return;

                let sFolder = containerFolder.get(sId);
                let tFolder = containerFolder.get(tId);
                if (!sFolder) sFolder = folderFromUriAtLevel(sNode?.data?.fileUri, currentKey);
                if (!tFolder) tFolder = folderFromUriAtLevel(tNode?.data?.fileUri, currentKey);
                if (!sFolder || !tFolder) return;

                cWithNodes++;

                const inScope = (k) => k === currentKey || k.startsWith(currentKey + '/');
                if (!inScope(sFolder) || !inScope(tFolder)) return;
                cInScope++;

                const nextOf = (k) => {
                    const baseLen = currentKey === '.' ? 0 : currentKey.split('/').length;
                    const parts = k.split('/');
                    const child = parts[baseLen];
                    return child ? ((currentKey === '.' ? '' : currentKey + '/') + child) : currentKey;
                };

                    const A = nextOf(sFolder);
                    const B = nextOf(tFolder);
                    if (!A || !B || A === B) return;
                    cCrossChild++;

                    const key = `${A}||${B}`;
                    if (!agg.has(key)) agg.set(key, { from: `folder:${A}`, to: `folder:${B}`, weight: 0 });
                    agg.get(key).weight += 1;
                });

                const folderEdges = Array.from(agg.values());

               vscodeApi.postMessage({ command: 'log', args: [
                `[Folders] scope="${currentKey}" nodes=${folderNodes.length} edges=${folderEdges.length}`,
                `  totalEdges=${cTotal} | withNodes=${cWithNodes} | inScope=${cInScope} | crossChild=${cCrossChild}`
                ]});
            return { folderNodes, folderEdges };
        }

        /**
         * Ensures that the SVG arrow marker is present in the root SVG element. If it doesn't exist,
         * it creates the necessary defs and marker elements with the appropriate geometry and styles for
         * the arrowheads of the diagram edges.
         *
         * @param {SVGElement} svgRoot - Root SVG element where to create the marker
         * @returns {SVGMarkerElement} The created or existing arrow marker element
         */
        function ensureArrowMarker(svgRoot) {
            const id = 'arrow-head';
            let m = svgRoot.querySelector(`marker#${id}`);
            if (m) return m;

            let defs = svgRoot.querySelector('defs');
            if (!defs) { defs = createSvgElement('defs'); svgRoot.insertBefore(defs, svgRoot.firstChild); }

            m = createSvgElement('marker', {
                id,
                viewBox: '0 0 36 18',     // wider and taller box
                refX: 35,                 // pushes the tip a bit further
                refY: 9,
                markerWidth: 22,          // pushes the tip a bit further
                markerHeight: 12,         // larger visual height
                orient: 'auto',
                markerUnits: 'userSpaceOnUse'
            });

            m.appendChild(createSvgElement('path', {
                d: 'M0,0 L36,9 L0,18 Z',
                fill: 'currentColor'
            }));

            defs.appendChild(m);
            return m;
        }

        /**
         * Determines the folder of a node at a specific level of the hierarchy. Extracts the
         * file path from the node's URI and calculates the corresponding folder based on
         * the current key and the directory structure starting from 'lib'.
         *
         * @param {Object} node - Node from which to extract folder information
         * @param {string} currentKey - Current folder key for the analysis level
         * @returns {string|null} The folder path or null if it cannot be determined
         */
        function folderOfNodeAtLevel(node, currentKey) {
            const uri = node?.data?.fileUri || '';
            const parts = uri.split('/');
            const libIdx = parts.indexOf('lib');
            if (libIdx === -1) return null;

            const folderParts = parts.slice(libIdx, parts.length - 1); 
            const base = currentKey ? currentKey.split('/') : [];
            for (let i = 0; i < base.length; i++) {
                if (folderParts[i] !== base[i]) return null;
            }
            
            const child = folderParts[base.length];
            return child ? `${currentKey ? currentKey + '/' : ''}${child}` : currentKey || '.';
        }

        /**
         * Builds a complete index of the folder hierarchy by analyzing all nodes
         * in the graph. Creates a map that associates each folder path with its
         * subfolders and contained files, facilitating navigation and visualization
         * of the directory structure.
         *
         * @returns {Map<string, Object>} Map with folder keys and objects with Sets of folders and files
         */
        function buildFolderHierarchyIndex() {
            const index = new Map(); // key: "lib/src/ui" ‚Üí {folders:Set, files:Set}

            allGraphNodes.forEach(n => {
                if (!n.data?.fileUri) return;
                const parts = n.data.fileUri.split('/');
                const libIdx = parts.indexOf('lib');
                if (libIdx === -1) return;

                const pathParts = parts.slice(libIdx, parts.length - 1);
                const fileName = parts[parts.length - 1];

                for (let i = 0; i < pathParts.length; i++) {
                const key = pathParts.slice(0, i + 1).join('/');
                if (!index.has(key)) index.set(key, { folders: new Set(), files: new Set() });

                if (i < pathParts.length - 1) {
                    index.get(key).folders.add(pathParts[i + 1]);
                } else {
                    index.get(key).files.add(fileName);
                }
                }
            });

            return index;
        }

        /**
         * Renders the complete folder diagram for a specific path. Handles the creation
         * of SVG layers, layout calculation, rendering of folder and file nodes, horizontal
         * edges, and navigation functionality through clicks. Includes detailed
         * debugging and error handling.
         *
         * @param {Array<string>} pathParts - Array of parts of the folder path to render
         */
        function renderFolderDiagram(pathParts) {
            try {
                mainLayer.innerHTML = '';

                const { folderNodes, folderEdges } = computeFolderGraph(pathParts);

                const currentKey = pathParts.join('/') || '.';
                const hierarchy = buildFolderHierarchyIndex();
                const filesHere = Array.from((hierarchy.get(currentKey)?.files || new Set()));
                const fileNodes = filesHere.map(fileName => {
                const hit = allGraphNodes.find(n => n.data?.fileUri?.endsWith('/' + fileName) && isContainerNode(n));
                return hit ? { ...hit } : { id:`file:${fileName}`, label:fileName, kind:'primitive' };
                });

                const edgeLayer = createSvgElement('g', { class: 'edge-layer' });
                const nodeLayer = createSvgElement('g', { class: 'node-layer' });
                mainLayer.appendChild(edgeLayer);
                mainLayer.appendChild(nodeLayer);

                const nodesForLayout = [...folderNodes, ...fileNodes];
                const primaryNodes = folderNodes.length ? folderNodes : fileNodes;

                const aggForColumn = folderEdges.map(e => ({ source: e.from, target: e.to }));

                let layout = calculateColumnLayout(nodesForLayout, aggForColumn);
                    if (!layout || (typeof layout.size === 'number' && layout.size === 0)) {
                    layout = simpleGridLayout(nodesForLayout);
                }

                nudgeTargetsForSteepEdges(layout, folderEdges);   

                const debugLog = (msg) => vscodeApi.postMessage({ command: 'log', args: [msg] });

                if (currentKey && currentKey.startsWith('lib/src/ui')) {
                    let count = 0;
                    debugLog(`[LAYOUT DEBUG] Expected levels for scope="${currentKey}"`);
                    primaryNodes.forEach(n => {
                        const lvl = aggForColumn.find(e => e.source === n.id || e.target === n.id);
                        debugLog(` - ${n.id} (${n.label}) conexiones=${lvl ? 's√≠' : 'no'}`);
                        const pos = layout.get(n.id);
                        if (pos) {
                        count++;
                        debugLog(`[LAYOUT POS] ${n.id} (${n.label}) -> x:${pos.x.toFixed(1)}, y:${pos.y.toFixed(1)}, w:${pos.width}, h:${pos.height}`);
                        } else {
                        debugLog(`[LAYOUT POS] ${n.id} (${n.label}) -> NO POSITION`);
                        }
                    });
                    debugLog(`[LAYOUT RESUMEN] scope="${currentKey}" placed=${count}/${primaryNodes.length}`);
                }


                // Render folders
                folderNodes.forEach(g => {
                const el = renderGroupNode(g, layout);
                if (!el) return;
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    historyStack.push(`folders:${g.key}`);
                    render();
                });
                });

                fileNodes.forEach(n => {
                    const el = renderCollapsedContainer(n, layout);
                    if (!el) return;

                    el.classList.add('file-pill');
                    el.dataset.file = n.label;

                    el.style.pointerEvents = 'all';
                    el.style.cursor = 'pointer';

                    el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const fileName = n.label;
                        const focusId  = findFocusIdForFile(fileName, currentKey);

                        vscodeApi.postMessage({ command:'log', args:[`[NAV] click file=${fileName} | focusId=${focusId}`] });

                        if (focusId) {
                        historyStack.push(focusId);
                        render();
                        } else {
                        historyStack.push(`folder-list:${currentKey}`);
                        render();
                        }
                    });

                    nodeLayer.appendChild(el);
                });

                renderFolderEdgesHorizontal(folderEdges, layout, edgeLayer);

                const kinds = new Set(['grouped-members', ...(fileNodes.length ? ['primitive'] : [])]);
                autoFit(svg, mainLayer);
                renderFolderBreadcrumb(pathParts);

            } catch (e) {
                vscodeApi.postMessage({ command: 'log', args: [`[WebView-ERROR] renderFolderDiagram: ${e.message}`] });
            }
        }

        /**
         * Searches for the appropriate focus ID for a specific file within a folder scope.
         * It iterates through all graph nodes looking for matches by file name and scope,
         * returning the ID of the container node or its parent for focus navigation.
         *
         * @param {string} fileName - Name of the file to search for
         * @param {string} currentKey - Current folder key to limit the search scope
         * @returns {string|null} The focus node ID or null if not found
         */
        function findFocusIdForFile(fileName, currentKey) {
            if (!fileName) return null;

            const scopePrefix = currentKey && currentKey !== '.'
                ? (currentKey.endsWith('/') ? currentKey : currentKey + '/')
                : '';

            for (const n of allGraphNodes) {
                const uri = n.data?.fileUri || '';
                if (!uri.endsWith('/' + fileName)) continue;
                if (scopePrefix && !uri.includes(scopePrefix)) continue;
                const focusId = isContainerNode(n) ? n.id : (n.parent || null);
                if (focusId && nodeMap.has(focusId)) return focusId;
            }
            return null;
        }

        /**
         * Creates a simple grid layout to distribute nodes in rows and columns.
         * It automatically calculates the number of columns based on the square root of the
         * number of nodes and assigns uniformly spaced positions with fixed dimensions.
         *
         * @param {Array<Object>} nodes - Array of nodes to position in the grid
         * @returns {Object} Object with a get() method that returns the position {x, y, width, height} by ID
         */
        function simpleGridLayout(nodes) {
            const cols = Math.max(1, Math.ceil(Math.sqrt(nodes.length)));
            const spacingX = 240;     // horizontal spacing
            const spacingY = 120;     // vertical spacing
            const width = 200;        // default card width
            const height = 80;        // default card height

            const map = new Map();
            nodes.forEach((node, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                map.set(node.id, {
                x: col * spacingX,
                y: row * spacingY,
                width,
                height
                });
            });

            
            return { get(id){ return map.get(id); } };
        }

        /**
         * Renders horizontal edges between folders with B√©zier curves. Handles the grouping
         * of multiple connections to the same destination, calculates line thickness based on weight,
         * and draws smooth curves with arrow markers. Includes options to display counts
         * and unify parallel edges.
         *
         * @param {Array<Object>} edges - Array of edges with from, to, and weight properties
         * @param {Object} layout - Layout object with node positions
         * @param {SVGElement} edgeLayer - SVG layer where to render the edges
         */
        function renderFolderEdgesHorizontal(edges, layout, edgeLayer) {
            const UNIFY_PAR_EDGES  = true;   // a single arrow per destination
            const SHOW_COUNT_LABEL = false;  // set to true if you want to show the total
            const MIN_STROKE = 1.0, MAX_STROKE = 4.0;
            const MIN_CTRL   = 80;           // minimum curvature
            const END_PAD    = 10;           // push inside the target so the tip is not cut off
            const STROKE_WIDTH = 2.5;

            edgeLayer.innerHTML = '';
            if (!edges?.length) return;

            ensureArrowMarker(svg);

            const groups = new Map();
            for (const e of edges) {
                if (!e.from || !e.to || e.from === e.to) continue;

                const A = layout.get(e.from), B = layout.get(e.to);
                if (!A || !B) continue;

                const leftId  = (A.x <= B.x) ? e.from : e.to;
                const rightId = (A.x <= B.x) ? e.to   : e.from;

                const k = UNIFY_PAR_EDGES ? `*||${rightId}` : `${leftId}||${rightId}`;

                if (!groups.has(k)) {
                groups.set(k, {
                    from: leftId,           
                    to:   rightId,
                    weight: 0,
                    items: [],
                    sources: new Set()     
                });
                }
                const g = groups.get(k);
                g.weight += (e.weight || 1);
                g.items.push({ from: leftId, to: rightId, w: (e.weight || 1) });
                g.sources.add(leftId);
            }

            let maxW = 1;
            for (const g of groups.values()) maxW = Math.max(maxW, g.weight);

            function drawCurve(axR, ay, bxL, by, weight) {
                const endX = bxL + END_PAD;
                const dx   = Math.max(MIN_CTRL, Math.abs(endX - axR) / 2);
                const cx1  = axR + dx,  cy1 = ay;
                const cx2  = endX - dx, cy2 = by;

                const path = createSvgElement('path', {
                d: `M ${axR} ${ay} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${endX} ${by}`,
                fill: 'none',
                stroke: '#9aa0a6',
                'stroke-linecap': 'round',
                'stroke-linejoin': 'round',
                'marker-end': 'url(#arrow-head)',
                class: 'edge-folder'
                });

                const ratio = Math.max(0, Math.min(1, weight / maxW));
                const sw = MIN_STROKE + (MAX_STROKE - MIN_STROKE) * ratio;
                path.setAttribute('stroke-width', STROKE_WIDTH);
                edgeLayer.appendChild(path);

                return { axR, ay, endX, by, sw };
            }

            for (const g of groups.values()) {
                const posTo = layout.get(g.to);
                if (!posTo) continue;

                const bxL = posTo.x - posTo.width / 2;
                const by  = posTo.y;

                if (UNIFY_PAR_EDGES) {
                    const srcPos = [];
                    for (const sid of g.sources) {
                        const p = layout.get(sid);
                        if (p) srcPos.push(p);
                    }
                    if (!srcPos.length) continue;

                    const avgY = srcPos.reduce((s, p) => s + p.y, 0) / srcPos.length;

                    let rep = srcPos[0];
                    let best = Math.abs(rep.y - avgY);
                    for (let i = 1; i < srcPos.length; i++) {
                        const d = Math.abs(srcPos[i].y - avgY);
                        if (d < best) { best = d; rep = srcPos[i]; }
                    }

                    let axR = rep.x + rep.width / 2;
                    let ay  = rep.y;

                    const bxL = posTo.x - posTo.width / 2;
                    const by  = posTo.y;
                    

                    drawCurve(axR, ay, bxL, by, g.weight);

                    if (SHOW_COUNT_LABEL) {
                        const midX = (axR + (bxL + END_PAD)) / 2;
                        const midY = (ay + by) / 2 - 6;
                        const label = createSvgElement('text', {
                        x: midX, y: midY,
                        'text-anchor': 'middle',
                        'font-size': '10px',
                        fill: '#6b7280'
                        });
                        label.textContent = `${g.weight}`;
                        edgeLayer.appendChild(label);
                    }
                } else {
                    for (const it of g.items) {
                        const posFrom = layout.get(it.from);
                        if (!posFrom) continue;
                        const axR = posFrom.x + posFrom.width / 2;
                        const ay  = posFrom.y;
                        const bxL = posTo.x - posTo.width / 2;
                        drawCurve(axR, ay, bxL, posTo.y, it.w);
                    }
                }
            }
        }

        /**
         * Calculates a hierarchical layout in columns for container nodes.
         * @param {Array} nodesToLayout - The class nodes to position.
         * @param {Map} aggregatedEdges - The aggregated edges that define dependencies.
         * @returns {Map} A map with the calculated positions and sizes for each node.
         */
       function calculateColumnLayout(nodesToLayout, aggregatedEdges) {
            const layout = new Map();
            const nodeWidth = 220;
            const nodeHeight = 40;
            const xSpacing = 280;
            const ySpacing = 60;

            if (!nodesToLayout || nodesToLayout.length === 0) return layout;

            const nodeLevels = new Map();
            nodesToLayout.forEach(n => nodeLevels.set(n.id, 0));

            const iterations = nodesToLayout.length;
            for (let i = 0; i < iterations; i++) {
                let changed = false;
                if (aggregatedEdges) {
                aggregatedEdges.forEach(edge => {
                    const s = nodeLevels.get(edge.source) ?? 0;
                    const t = nodeLevels.get(edge.target) ?? 0;
                    if (t <= s) {
                    nodeLevels.set(edge.target, s + 1);
                    changed = true;
                    }
                });
                }
                if (!changed) break;
            }

            vscodeApi.postMessage({
                command: 'log',
                args: ['[Layout] levels (raw):', JSON.stringify(Array.from(nodeLevels.entries()))]
            });

            const usedLevels = Array.from(new Set(Array.from(nodeLevels.values()))).sort((a,b) => a - b);
            const levelRemap = new Map(usedLevels.map((lvl, idx) => [lvl, idx]));
            for (const [id, lvl] of nodeLevels.entries()) {
                nodeLevels.set(id, levelRemap.get(lvl));
            }

            vscodeApi.postMessage({
                command: 'log',
                args: [
                `[Layout] used levels=${JSON.stringify(usedLevels)} ` +
                `‚Üí remap=${JSON.stringify(usedLevels.map(l => `${l}->${levelRemap.get(l)}`))}`
                ]
            });

            const nodesInColumns = {};
            nodesToLayout.forEach(node => {
                const lvl = nodeLevels.get(node.id) || 0;
                (nodesInColumns[lvl] ||= []).push(node);
            });

            Object.keys(nodesInColumns).forEach(levelStr => {
                const level = parseInt(levelStr, 10);
                const columnNodes = nodesInColumns[level];
                if (!Array.isArray(columnNodes) || columnNodes.length === 0) return;

                const nodeHeights = columnNodes.map(node => {
                if (node.id === focusedContainerId) {
                    const childrenCount = allGraphNodes.filter(n => n.parent === node.id).length;
                    return Math.max(nodeHeight, 60 + childrenCount * 40);
                }
                return nodeHeight;
                });

                const totalHeight = nodeHeights.reduce((s, h) => s + h, 0) + (columnNodes.length - 1) * ySpacing;
                let currentY = -totalHeight / 2;

                columnNodes.forEach((node, idx) => {
                const h = nodeHeights[idx];
                layout.set(node.id, {
                    x: level * xSpacing,
                    y: currentY + h / 2,
                    width: nodeWidth,
                    height: h
                });
                currentY += h + ySpacing;
                });
            });

            let minX = Infinity;
            layout.forEach(pos => { if (pos) minX = Math.min(minX, pos.x); });
            if (isFinite(minX) && minX !== 0) {
                layout.forEach(pos => { pos.x -= minX; });
            }

            return layout;
        }

        /**
         * Adjusts the positions of target nodes to prevent overly steep or overlapping edges.
         * Analyzes the horizontal distance between connected nodes and shifts targets to the right
         * when they are too close to their sources, improving diagram readability.
         *
         * @param {Object} layout - Layout object with node positions
         * @param {Array<Object>} edges - Array of edges between nodes
         * @param {number} minDx - Minimum required horizontal distance (default: 160)
         * @param {number} maxShift - Maximum allowed displacement (default: 220)
         */
        function nudgeTargetsForSteepEdges(layout, edges, minDx = 160, maxShift = 220) {
            const groups = new Map();
            for (const e of edges) {
                const A = layout.get(e.from), B = layout.get(e.to);
                if (!A || !B || e.from === e.to) continue;
                const leftId  = (A.x <= B.x) ? e.from : e.to;
                const rightId = (A.x <= B.x) ? e.to   : e.from;
                const k = rightId;
                if (!groups.has(k)) groups.set(k, { to: rightId, sources: new Set() });
                groups.get(k).sources.add(leftId);
            }

            for (const g of groups.values()) {
                const posTo = layout.get(g.to);
                if (!posTo) continue;

                const srcPos = [...g.sources].map(id => layout.get(id)).filter(Boolean);
                if (!srcPos.length) continue;
                const avgY = srcPos.reduce((s,p)=>s+p.y,0) / srcPos.length;
                let rep = srcPos[0], best = Math.abs(rep.y - avgY);
                for (let i=1;i<srcPos.length;i++){
                const d = Math.abs(srcPos[i].y - avgY);
                if (d < best) { best = d; rep = srcPos[i]; }
                }

                const dx = posTo.x - rep.x;
                const dy = Math.abs(posTo.y - rep.y);

                if (dx < minDx) {
                const need = Math.min(maxShift, minDx - dx);
                posTo.x += need;
                }
            }
        }


        /**
         * Renders the overview showing the architectural layers of the project.
         * Creates visual elements for each layer with icons, labels, and node counters,
         * organizing them vertically. Handles navigation to specific layer views
         * through click events.
         */
        function renderOverview() {
            mainLayer.innerHTML = ''; 

            const oldLegend = document.querySelector('.legend');
            if (oldLegend) {
                oldLegend.style.display = 'none';
            }

            const layerDisplayInfo = {
                view:    { label: t('overview.views'), icon: 'üì±', colorClass: 'color-view' },
                state:   { label: t('overview.state'), icon: 'üß†', colorClass: 'color-state' },
                service: { label: t('overview.service'), icon: 'üåê', colorClass: 'color-service' },
                model:   { label: t('overview.model'), icon: 'üì¶', colorClass: 'color-model' },
                utility: { label: t('overview.utility'), icon: 'üõ†Ô∏è', colorClass: 'color-utility' }
            };

            const layerCounts = {};
           
            allGraphNodes.forEach(node => {
                const layer = node.data.layer;
                if (layer && layer !== 'member') {
                    layerCounts[layer] = (layerCounts[layer] || 0) + 1;
                }
            });

            const overviewItems = Object.keys(layerCounts)
                .map(layerKey => ({
                    kind: layerKey,
                    count: layerCounts[layerKey],
                    ...layerDisplayInfo[layerKey]
                }))
                .filter(item => item.count > 0);

            const itemHeight = 40;
            const itemWidth = 180; 
            const itemSpacing = 20;
            const totalHeight = overviewItems.length * (itemHeight + itemSpacing) - itemSpacing;
            let currentY = -totalHeight / 2;

            overviewItems.forEach(item => {
                const itemGroup = createSvgElement('g', {
                    'class': `overview-item ${item.colorClass}`,
                    'transform': `translate(0, ${currentY})`,
                });

                const rect = createSvgElement('rect', {
                    'class': 'item-rect',
                    'x': -itemWidth / 2, 'y': -itemHeight / 2,
                    'width': itemWidth, 'height': itemHeight,
                });

                const icon = createSvgElement('text', {
                    'class': 'item-icon',
                    'x': -itemWidth / 2 + 20, 
                    'y': 3,
                });
                icon.textContent = item.icon;

                const label = createSvgElement('text', {
                    'class': 'item-label',
                    'x': -itemWidth / 2 + 45, 
                    'y': 3,
                });
                label.textContent = item.label;

                const badgeRadius = 10;
                const badgeCx = itemWidth / 2 - badgeRadius - 5;
                const badgeCy = 0; 

                const badgeBg = createSvgElement('circle', {
                    'class': 'item-badge-bg',
                    'cx': badgeCx, 'cy': badgeCy, 'r': badgeRadius
                });
                const badgeText = createSvgElement('text', {
                    'class': 'item-badge-text',
                    'x': badgeCx, 'y': badgeCy + 1,
                });
                badgeText.textContent = item.count;

                itemGroup.appendChild(rect);
                itemGroup.appendChild(icon);
                itemGroup.appendChild(label);
                itemGroup.appendChild(badgeBg);
                itemGroup.appendChild(badgeText);

                itemGroup.addEventListener('click', () => {
                    historyStack.push(`overview-${item.kind}`);
                    render();
                });

                mainLayer.appendChild(itemGroup);
                currentY += itemHeight + itemSpacing;
            });

            if (overviewItems.length === 0) {
                const message = createSvgElement('text', {
                    'fill': 'var(--color-text)',
                    'font-size': '14px',
                    'text-anchor': 'middle'
                });
                message.textContent = 'No architectural layers found in the project.';
                mainLayer.appendChild(message);
            }

            autoFit(svg, mainLayer);
        }

        /**
         * Renders an individual pill within a parent group with full functionality.
         * Creates the visual SVG element, determines the pill type based on the node type,
         * calculates appropriate dimensions, and sets up all event listeners for interaction
         * (click, hover, context menu). Includes detailed logging for debugging.
         *
         * @param {Object} node - Node to render as a pill
         * @param {SVGElement} parentGroup - Parent SVG group to add the pill to
         * @param {number} yOffset - Vertical offset for positioning the pill
         * @param {number} parentWidth - Width of the parent container to calculate dimensions
         * @returns {SVGElement|null} The created pill SVG element or null if there is an error
         */
        function renderPill(node, parentGroup, yOffset, parentWidth) {
            try {
                vscodeApi.postMessage({
                    command: 'log',
                    args: [`[DEBUG] renderPill ‚Üí label: ${JSON.stringify(node.label)}, kind: ${node.kind}`]
                });

                const cleanLabel = (node.label || '').trim();
                let pillKind;
                
                if (node.kind === 'package_container') {
                    const packageType = node.data?.source?.packageType;
                    if (packageType === 'custom') {
                        pillKind = 'external-package'; 
                    } else {
                        pillKind = 'custom-package';  
                    }
                } else if (node.kind === 'group') {
                    pillKind = 'collapsed-member';
                } else if (['method', 'function', 'constructor'].includes(node.kind)) {
                    pillKind = 'method';
                } else if (['field', 'property'].includes(node.kind)) {
                    pillKind = 'field';
                } else if (node.kind === 'folder-center') {
                    pillKind = 'folder-center';
                } else {
                    pillKind = 'primitive';
                }

                const pillHeight = 28;
                const baseWidth = node.label.length * 8 + 40;
                const pillWidth = Math.max(parentWidth * 0.85, baseWidth);

                const pillGroup = createSvgElement('g', {
                    class: `pill pill-${pillKind}`,
                    transform: `translate(0, ${yOffset})`,
                    'data-id': node.id,
                    'data-kind': node.kind
                });

                const rect = createSvgElement('rect', {
                    class: 'pill-rect',
                    x: -pillWidth / 2,
                    y: -pillHeight / 2,
                    width: pillWidth,
                    height: pillHeight,
                    rx: 6,
                    ry: 6
                });

                const text = createSvgElement('text', {
                    class: 'pill-label',
                    x: 0,
                    y: 0,
                    'text-anchor': 'middle',
                    'dominant-baseline': 'middle'
                });
                text.textContent = node.label;

                pillGroup.appendChild(rect);
                pillGroup.appendChild(text);

                if (node.kind !== 'folder-center') {
                    pillGroup.addEventListener('click', (e) => {
                        e.stopPropagation();
                        pushRoute(node.id);
                        render();
                    });

                    pillGroup.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (node.kind === 'field' || node.kind === 'property') {
                            contextMenu.dataset.nodeId = node.id;
                            contextMenu.style.left = `${e.clientX}px`;
                            contextMenu.style.top = `${e.clientY}px`;
                            contextMenu.classList.add('visible');
                        }
                    });

                    pillGroup.addEventListener('mouseover', (event) => {
                        event.stopPropagation();
                        highlight(node.id, true, event);
                    });

                    pillGroup.addEventListener('mouseout', (event) => {
                        event.stopPropagation();
                        highlight(null, false, event);
                    });

                    pillGroup.addEventListener('mousemove', (event) => {
                        tooltip.style.left = `${event.clientX + 15}px`;
                        tooltip.style.top = `${event.clientY + 15}px`;
                    });
                } else {
                    pillGroup.style.cursor = 'default';
                }

                parentGroup.appendChild(pillGroup);
                return pillGroup;

            } catch (e) {
                vscodeApi.postMessage({
                    command: 'log',
                    args: [`[WebView-ERROR] Critical failure in renderPill: ${e.message}`, `Stack: ${e.stack}`]
                });
                return null;
            }
        }

        /**
         * Creates only the visual representation of a pill without interactive functionality.
         * Generates the basic SVG elements (rectangle and text) with the appropriate style based
         * on the node type, but without adding event listeners. Useful for previews
         * or non-interactive elements.
         *
         * @param {Object} node - Node from which to create the visual representation
         * @param {number} parentWidth - Width of the parent container to calculate dimensions
         * @returns {Object|null} Object with {pillGroup, pillWidth, pillHeight} or null if there is an error
         */
        function createPillVisual(node, parentWidth) {
            try {
                const pillHeight = 28;
                const baseWidth = node.label.length * 8 + 40;
                const pillWidth = Math.max(parentWidth * 0.85, baseWidth);

                let pillKind;
                if (node.kind === 'package_container') {
                    const packageType = node.data?.source?.packageType;
                    if (packageType === 'custom') {
                        pillKind = 'external-package';
                    } else {
                        pillKind = 'custom-package';
                    }
                } else if (node.kind === 'group') {
                    pillKind = 'collapsed-member';
                } else if (['method', 'function', 'constructor'].includes(node.kind)) {
                    pillKind = 'method';
                } else if (['field', 'property'].includes(node.kind)) {
                    pillKind = 'field';
                } else if (node.kind === 'folder-center') {
                    pillKind = 'folder-center';
                } else {
                    pillKind = 'primitive';
                }

                const pillGroup = createSvgElement('g', {
                    class: `pill pill-${pillKind}`,
                    transform: `translate(0, 0)`,
                    'data-id': node.id,
                    'data-kind': node.kind
                });

                const rect = createSvgElement('rect', {
                    class: 'pill-rect',
                    x: -pillWidth / 2,
                    y: -pillHeight / 2,
                    width: pillWidth,
                    height: pillHeight,
                    rx: 6,
                    ry: 6
                });

                const text = createSvgElement('text', {
                    class: 'pill-label',
                    x: 0,
                    y: 0,
                    'text-anchor': 'middle',
                    'dominant-baseline': 'middle'
                });
                text.textContent = node.label;

                pillGroup.appendChild(rect);
                pillGroup.appendChild(text);
                
                vscodeApi.postMessage({
                    command: 'log',
                    args: [`[createPillVisual] ‚úÖ Visual pill created: ${node.label} (${pillKind}, ${pillWidth}x${pillHeight})`]
                });
                
                return { pillGroup, pillWidth, pillHeight };

            } catch (e) {
                vscodeApi.postMessage({
                    command: 'log',
                    args: [`[createPillVisual] ERROR: ${e.message}`, e.stack]
                });
                return null;
            }
        }

        /**
         * Renders a group node (folder or container) in the diagram. Creates the necessary SVG
         * elements including a rectangle, icon, and label, positioning them according to the layout.
         * Sets up expand/collapse functionality via click and applies specific styles
         * according to the layer type (external_packages, custom_packages, etc.).
         *
         * @param {Object} groupNode - Group node to render
         * @param {Object} layout - Layout object with node positions
         * @returns {SVGElement|null} The created group SVG element or null if there is an error
         */
        function renderGroupNode(groupNode, layout) {
            try {
                const nodeLayout = layout.get(groupNode.id);
                
                if (!nodeLayout) return null;

                const group = createSvgElement('g', {
                    'transform': `translate(${nodeLayout.x}, ${nodeLayout.y})`,
                    'class': `node overview-item color-${groupNode.layer}`, 
                    'data-id': groupNode.id,                             
                    'cursor': 'pointer'
                });
                    
                group.addEventListener('click', () => {
                    if (expandedGroupIds.has(groupNode.id)) { 
                        expandedGroupIds.delete(groupNode.id);
                    } else {
                        expandedGroupIds.add(groupNode.id);
                    }
                    render(); 
                });

                const containerWidth = (groupNode.layer === 'external_packages' || groupNode.layer === 'custom_packages')
                    ? nodeLayout.width + 35 
                    :nodeLayout.width;

               

                const rect = createSvgElement('rect', {
                    'class': 'item-rect',
                    'x': -nodeLayout.width / 2, 
                    'y': -nodeLayout.height / 2,
                    'width': containerWidth, 
                    'height': nodeLayout.height
                });

                const layerDisplayInfo = {
                    view:    { icon: 'üì±' },
                    state:   { icon: 'üß†' },
                    service: { icon: 'üåê' },
                    model:   { icon: 'üì¶' },
                    utility: { icon: 'üõ†Ô∏è' },
                    member:  { icon: 'üß©' },
                    external_packages: { icon: 'üîß' },
                    custom_packages: { icon: 'üì¶' }
                };

                const iconXPosition = (groupNode.layer === 'external_packages' || groupNode.layer === 'custom_packages')
                    ? -nodeLayout.width / 2 + 15 
                    : -nodeLayout.width / 2 + 40;

                const labelXPosition = (groupNode.layer === 'external_packages' || groupNode.layer === 'custom_packages')
                    ? -nodeLayout.width / 2 + 40 
                    : -nodeLayout.width / 2 + 70; 

                const icon = createSvgElement('text', {
                    'class': 'item-icon', 
                    'font-size': '20px',
                    'x': iconXPosition ,
                    'y': 5
                });
                icon.textContent = layerDisplayInfo[groupNode.layer]?.icon || '';

                const label = createSvgElement('text', {
                    'class': 'item-label',
                    'x': labelXPosition,
                    'y': 5
                });
                label.textContent = groupNode.label;

                group.appendChild(rect);
                group.appendChild(icon);
                group.appendChild(label);

                let nodeLayer = mainLayer.querySelector('.node-layer');
                if (nodeLayer) {
                    nodeLayer.appendChild(group);
                }
                
                return group;
            }
            catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [
                        `[WebView-ERROR] Critical failure in renderGroupNode: ${e.message}`,
                        `Stack: ${e.stack}`
                    ]
                });
            }
        }
        
        /**
         * Updates the visual state of the navigation buttons based on the history.
         * Enables or disables the back button depending on whether there are elements
         * in the history stack to navigate back to.
         */
        function updateNavButtonsState() {
            if (historyStack.length > 0) {
                backButton.classList.remove('disabled');
            } else {
                backButton.classList.add('disabled');
            }
        }

        /**
         * Renders the list view for a specific layer of the project. Creates a container
         * with search functionality, filters nodes by layer type, and displays them
         * in an alphabetically sorted list. Includes a real-time search field
         * that filters by node name and file path.
         *
         * @param {string} kind - Layer type to display (view, state, service, model, utility)
         */
        function renderListView(kind) {
            try {
                const diagramContainer = document.getElementById('diagram-container');
                const listContainer = document.getElementById('list-view-container');
                
                diagramContainer.style.display = 'none';
                listContainer.style.display = 'block';
                listContainer.innerHTML = ''; 

                const searchContainer = document.createElement('div');
                searchContainer.className = 'search-container';
                
                const searchInput = document.createElement('input');
                searchInput.className = 'search-input';
                searchInput.type = 'text';
                searchInput.placeholder = t('search.placeholder', kind.charAt(0).toUpperCase() + kind.slice(1));
                
                searchContainer.appendChild(searchInput);
                listContainer.appendChild(searchContainer);

                const resultsContainer = document.createElement('div');
                listContainer.appendChild(resultsContainer);

                const nodesToList = allGraphNodes
                    .filter(n => n.data.layer === kind)
                    .sort((a, b) => a.label.localeCompare(b.label));
                
                displayFilteredList(nodesToList, resultsContainer);

                searchInput.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    const filteredNodes = nodesToList.filter(node => 
                        node.label.toLowerCase().includes(searchTerm) || 
                        (node.data.fileUri && node.data.fileUri.toLowerCase().includes(searchTerm))
                    );
                    displayFilteredList(filteredNodes, resultsContainer);
                });
            } catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[WebView-ERROR] Critical failure in renderListView: ${e.message}`, `Stack: ${e.stack}`]
                });
            }
        }

        /**
         * Hides the floating "Back to Overview" button by setting its display to 'none'.
         * Used when navigating to views where this button should not be visible.
         */
        function hideBackToOverviewButton() {
            const backToOverviewBtn = document.getElementById('back-to-overview-float');
            if (backToOverviewBtn) {
                backToOverviewBtn.style.display = 'none';
            }
        }

        /**
         * Displays a filtered list of nodes grouped by feature. Calculates importance
         * metrics based on in- and out-degrees, groups nodes by feature
         * extracted from the file path, and creates a rich interface with visual indicators.
         * Includes a floating button to return to the overview and handles navigation events.
         *
         * @param {Array<Object>} nodes - Array of nodes to display in the list
         * @param {HTMLElement} container - DOM container where to render the list
         */
        function displayFilteredList(nodes, container) {
            try{
                container.innerHTML = ''; 

                let backToOverviewBtn = document.getElementById('back-to-overview-float');
        
                if (!backToOverviewBtn) {
                    backToOverviewBtn = document.createElement('button');
                    backToOverviewBtn.id = 'back-to-overview-float';
                    backToOverviewBtn.innerHTML = '‚Üê Overview';
                    backToOverviewBtn.style.cssText = `
                        position: fixed;
                        bottom: 25px;
                        left: 25px;
                        z-index: 15;
                        background-color: #6f42c1;
                        color: white;
                        border: none;
                        padding: 12px 20px;
                        border-radius: 25px;
                        font-size: 14px;
                        font-weight: 500;
                        cursor: pointer;
                        box-shadow: 0 4px 12px rgba(111, 66, 193, 0.3);
                        backdrop-filter: blur(8px);
                        transition: all 0.3s ease;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        border: 1px solid rgba(255, 255, 255, 0.2);
                    `;
                    
                    backToOverviewBtn.addEventListener('mouseenter', () => {
                        backToOverviewBtn.style.transform = 'translateY(-2px)';
                        backToOverviewBtn.style.boxShadow = '0 6px 16px rgba(111, 66, 193, 0.4)';
                        backToOverviewBtn.style.backgroundColor = '#5a2d91';
                    });
                    
                    backToOverviewBtn.addEventListener('mouseleave', () => {
                        backToOverviewBtn.style.transform = 'translateY(0)';
                        backToOverviewBtn.style.boxShadow = '0 4px 12px rgba(111, 66, 193, 0.3)';
                        backToOverviewBtn.style.backgroundColor = '#6f42c1';
                    });
                    
                    backToOverviewBtn.addEventListener('click', () => {
                        historyStack = [];
                        render();
                    });
                    
                    document.body.appendChild(backToOverviewBtn);
                } else {
                    backToOverviewBtn.style.display = 'flex';
                }

                if (nodes.length === 0) {
                    container.textContent = t('search.noResults');
                    return;
                }
                nodes.forEach(node => {
                    if (!node.inDegree || !node.outDegree) {
                        const incomingEdges = allGraphEdges.filter(edge => 
                            getContainerId(edge.target) === node.id
                        );
                        
                        const outgoingEdges = allGraphEdges.filter(edge => 
                            getContainerId(edge.source) === node.id
                        );
                        
                        node.inDegree = incomingEdges.length;
                        node.outDegree = outgoingEdges.length;
                        
                        console.log(`[${node.label}] inDegree: ${node.inDegree}, outDegree: ${node.outDegree}`);
                    }
                });

                const groupedByFeature = nodes.reduce((acc, node) => {
                    let featureName = 'General';
                    const pathParts = node.data.fileUri.split('/');
                    const featuresIndex = pathParts.indexOf('features');
                    const libIndex = pathParts.indexOf('lib');

                    if (featuresIndex !== -1 && featuresIndex + 1 < pathParts.length) {
                        featureName = pathParts[featuresIndex + 1];
                    } else if (libIndex !== -1 && libIndex + 1 < pathParts.length) {
                        const potentialFeature = pathParts[libIndex + 1];
                        if (!potentialFeature.endsWith('.dart')) {
                            featureName = potentialFeature;
                        }
                    }

                    featureName = featureName.charAt(0).toUpperCase() + featureName.slice(1).replace(/_/g, ' ');

                    if (!acc[featureName]) acc[featureName] = [];
                    acc[featureName].push(node);
                    return acc;
                }, {});

                Object.keys(groupedByFeature).sort().forEach(featureName => {
                    const header = document.createElement('h2');
                    header.className = 'list-view-header';
                    header.textContent = featureName;
                    container.appendChild(header);

                    const list = document.createElement('ul');
                    list.className = 'list-view-items';

                    const featureNodes = groupedByFeature[featureName];
                    featureNodes.sort((a, b) => getNodeImportanceScore(b) - getNodeImportanceScore(a));

                    featureNodes.forEach(node => {
                        const item = document.createElement('li');

                        const score = getNodeImportanceScore(node);
                        let importanceClass = 'importance-low';
                        if (score > 40) importanceClass = 'importance-high';
                        else if (score > 15) importanceClass = 'importance-medium';

                        item.className = `list-view-item ${importanceClass}`;

                        const labelSpan = document.createElement('span');
                        labelSpan.className = 'item-label';
                        labelSpan.textContent = node.label;
                        labelSpan.title = `Importancia: ${score}\nArchivo: ${node.data.fileUri.split('/').slice(-2).join('/')}`;

                        const indicatorsDiv = document.createElement('div');
                        indicatorsDiv.className = 'item-indicators';

                        const inDegree = node.inDegree || 0;
                        const outDegree = node.outDegree || 0;

                        vscodeApi.postMessage({ 
                            command: 'log', 
                            args: [
                                `[DEBUG] ${node.label}: inDegree=${inDegree}, outDegree=${outDegree}`,
                                
                            ]
                        });

                        let indicatorsHTML = '';
                        if (inDegree > 0) {
                            indicatorsHTML += `<span class="indicator-in" title="Responsibility: ${inDegree} files depend on this">üì• ${inDegree}</span>`;
                        }
                        if (outDegree > 0) {
                            indicatorsHTML += `<span class="indicator-out" title="Dependency: This file depends on${outDegree} others">üì§ ${outDegree}</span>`;
                        }
                        indicatorsDiv.innerHTML = indicatorsHTML;

                        item.appendChild(labelSpan);
                        item.appendChild(indicatorsDiv);

                        item.addEventListener('click', () => {
                            pushRoute(node.id);
                            render();
                        });
                        list.appendChild(item);
                    });

                    container.appendChild(list);
                });
            }catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [
                        `[WebView-ERROR] Critical failure in displayFilteredList: ${e.message}`,
                        `Stack: ${e.stack}`
                    ]
                });
            }
        }

        /**
         * Finds the ID of a container node based solely on the file name.
         * It iterates through all container nodes in the graph looking for exact
         * matches at the end of the file URI with the provided name.
         *
         * @param {string} fileName - Name of the file to search for
         * @returns {string|null} The container node ID or null if not found
         */
        function findContainerIdByFileName(fileName) {
            if (!fileName) return null;
            for (const n of allGraphNodes) {
                if (!isContainerNode(n)) continue;
                const uri = n.data?.fileUri || '';
                if (uri.endsWith('/' + fileName)) return n.id;
            }
            return null;
        }

        /**
         * Calculates an importance score for a node based on its architectural layer
         * and in-degree. State nodes receive the highest score (50), followed by
         * views and services (30), models (10), and utilities (5). It adds additional
         * points based on the number of incoming dependencies multiplied by 2.
         *
         * @param {Object} node - Node for which to calculate importance
         * @returns {number} The importance score of the node
         */
        function getNodeImportanceScore(node) {
            let score = 0;
            if (!node) return score;

            const layer = node.data.layer;
            const inDegree = node.inDegree || 0;

            switch (layer) {
                case 'state':   score += 50; break; 
                case 'view':    score += 30; break; 
                case 'service': score += 30; break;
                case 'model':   score += 10; break;
                case 'utility': score += 5;  break;
            }

            score += (inDegree * 2);

            return score;
        }

       
        /**
         * Gets the neighborhood data for the focus view of a specific node.
         * Identifies all relevant container nodes and edges that should be displayed
         * when focusing on a particular node, including the focus node, its members,
         * connected nodes, and their respective container parents.
         *
         * @param {string} focusNodeId - ID of the node to focus on
         * @returns {Object} Object with nodesToRender and edgesToRender arrays
         */
        function getFocusedNeighborhoodData(focusNodeId) {
            const containerNodesInView = new Set();
            const edgesInView = new Set();
            const focusNode = nodeMap.get(focusNodeId);

            if (!focusNode) return { nodesToRender: [], edgesToRender: [] };

            containerNodesInView.add(focusNode);

            const membersOfFocusNode = allGraphNodes.filter(n => n.parent === focusNodeId);
            const memberIdsOfFocusNode = new Set(membersOfFocusNode.map(m => m.id));

            allGraphEdges.forEach(edge => {
                const sourceContainerId = getContainerId(edge.source);
                const targetContainerId = getContainerId(edge.target);

                const isSourceRelevant = (sourceContainerId === focusNodeId) || memberIdsOfFocusNode.has(edge.source);
                const isTargetRelevant = (targetContainerId === focusNodeId) || memberIdsOfFocusNode.has(edge.target);

                if ((isSourceRelevant && !isTargetRelevant) || (!isSourceRelevant && isTargetRelevant)) {
                    edgesInView.add(edge);

                    [edge.source, edge.target].forEach(nodeId => {
                        const node = nodeMap.get(nodeId);
                        if (node) containerNodesInView.add(node);
                    });

                    [edge.source, edge.target].forEach(nodeId => {
                        const node = nodeMap.get(nodeId);
                        if (node?.parent) {
                            const parent = nodeMap.get(node.parent);
                            if (parent) containerNodesInView.add(parent);
                        }
                    });
                }
            });

            const finalNodesInView = new Set(containerNodesInView);
            containerNodesInView.forEach(containerNode => {
                allGraphNodes.forEach(potentialMember => {
                    if (potentialMember.parent === containerNode.id) {
                        finalNodesInView.add(potentialMember);
                    }
                });
            });

            return { 
                nodesToRender: Array.from(finalNodesInView), 
                edgesToRender: Array.from(edgesInView) 
            };
        }

        /**
         * Highlights a node and its connections on hover. Applies an unfocus class
         * to the main graph, displays detailed edges connected to the node, hides
         * overlapping aggregated edges, and shows a tooltip with node information
         * including in- and out-degrees.
         *
         * @param {string} nodeId - ID of the node to highlight
         * @param {boolean} isHovering - Whether hovering over the node
         * @param {Event} event - Mouse event to position the tooltip
         */
        function highlight(nodeId, isHovering, event) {
            try {
                clearHoverHighlights();
                if (!isHovering || !nodeId) return;

                const mainNode = nodeMap.get(nodeId);
                if (!mainNode) return;

                mainLayer.classList.add('graph-unfocused');
                const elementsToHighlight = new Set();

                const mainElement = mainLayer.querySelector(`g[data-id='${nodeId}']`);
                if (mainElement) elementsToHighlight.add(mainElement);
                if (mainNode.parent) {
                    const containerElement = mainLayer.querySelector(`g[data-id='${mainNode.parent}']`);
                    if (containerElement) elementsToHighlight.add(containerElement);
                }

                const connectedEdges = findConnectedDetailedEdges(nodeId);
                const visibleNodeIds = new Set(Array.from(mainLayer.querySelectorAll('g.node[data-id]')).map(el => el.dataset.id));
                const visibleEdges = connectedEdges.filter(edge => {
                    const sourceContainer = getContainerId(edge.source);
                    const targetContainer = getContainerId(edge.target);
                    return visibleNodeIds.has(sourceContainer) && visibleNodeIds.has(targetContainer);
                });

                if (visibleEdges.length > 0) {
                    const aggregationKeysToHide = new Set();
                    visibleEdges.forEach(edge => {
                        const detailedPath = mainLayer.querySelector(`path.detailed-edge[data-edge-key='detail-${edge.id}']`);
                        if (detailedPath) {
                            detailedPath.classList.remove('hidden');
                            detailedPath.classList.add('visible');
                            elementsToHighlight.add(detailedPath);
                            aggregationKeysToHide.add(detailedPath.dataset.aggregationKey);

                            const otherNodeId = getContainerId(edge.source) === getContainerId(nodeId) ? getContainerId(edge.target) : getContainerId(edge.source);
                            const otherElement = mainLayer.querySelector(`g[data-id='${otherNodeId}']`);
                            if(otherElement) elementsToHighlight.add(otherElement);
                        }
                    });
                    aggregationKeysToHide.forEach(key => {
                        const aggPath = mainLayer.querySelector(`path.aggregated-edge[data-aggregation-key='${key}']`);
                        if (aggPath) aggPath.classList.add('hidden');
                    });
                }

                elementsToHighlight.forEach(el => { if(el) el.classList.add('highlight'); });

                tooltip.innerHTML = `<b>${mainNode.label}</b><br><small>(${mainNode.kind})</small><br><hr style="margin:2px 0; border-color: #555;"><small>Entrantes: ${mainNode.inDegree || 0} | Salientes: ${mainNode.outDegree || 0}</small>`;
                tooltip.classList.add('visible');
                tooltip.style.left = `${event.clientX + 15}px`;
                tooltip.style.top = `${event.clientY + 15}px`;
            } catch (e) {
                vscodeApi.postMessage({ command: 'log', args: [`[WebView-ERROR] Critical failure in highlight: ${e.message}`] });
            }
        }

        /**
         * Highlights the specific path between two nodes by showing the visual connection.
         * Applies an unfocus class to the graph and highlights the source and target nodes
         * along with the aggregated edge that connects them, searching in both directions
         * of the connection.
         *
         * @param {string} sourceId - Source node ID
         * @param {string} targetId - Target node ID
         */
        function highlightPath(sourceId, targetId) {
            try{
                mainLayer.classList.add('graph-unfocused');
                mainLayer.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));

                const sourceContainerId = getContainerId(sourceId);
                const targetContainerId = getContainerId(targetId);

                const sourceNodeEl = mainLayer.querySelector(`g.node[data-id='${sourceContainerId}']`);
                const targetNodeEl = mainLayer.querySelector(`g.node[data-id='${targetContainerId}']`);
                if (sourceNodeEl) sourceNodeEl.classList.add('highlight');
                if (targetNodeEl) targetNodeEl.classList.add('highlight');

                let edgeEl = mainLayer.querySelector(`path.aggregated-edge[data-aggregation-key='${sourceContainerId}->${targetContainerId}']`);
                if (!edgeEl) {
                    edgeEl = mainLayer.querySelector(`path.aggregated-edge[data-aggregation-key='${targetContainerId}->${sourceContainerId}']`);
                }
                if (edgeEl) {
                    edgeEl.classList.add('highlight');
                } else {
                    vscodeApi.postMessage({ command: 'log', args: [`[WebView] No aggregated edge found for the path: ${sourceContainerId} -> ${targetContainerId}`]});
                }
            }catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [
                        `[WebView-ERROR] Critical failure in highlightPath: ${e.message}`,
                        `Stack: ${e.stack}`
                    ]
                });
                
            }
        }

        /**
         * Renders the navigation breadcrumb for the folder view showing
         * the current path. Creates navigable links for each part of the path and
         * adds an optional button to go back to the previous object if the previous
         * navigation was not a folder view.
         *
         * @param {Array<string>} pathParts - Array of parts of the current folder path
         */
        function renderFolderBreadcrumb(pathParts) {
            const bc = document.getElementById('breadcrumb');
            if (!bc) return;

            bc.innerHTML = '';

            const baseRoute = 'folders:';
            const parts = ['.'].concat(pathParts); // "." = folder root

            parts.forEach((p, i) => {
                const a = document.createElement('a');
                a.href = '#';
                a.textContent = (p === '.') ? 'Carpetas' : p;
                a.onclick = (e) => {
                e.preventDefault();
                const targetParts = (p === '.') ? [] : pathParts.slice(0, i);
                historyStack.push(`${baseRoute}${targetParts.join('/') || '.'}`);
                render();
                };
                bc.appendChild(a);
                if (i < parts.length - 1) {
                bc.appendChild(document.createTextNode(' ‚Ä∫ '));
                }
            });

            const prevId = historyStack.length > 1 ? historyStack[historyStack.length - 2] : null;
            if (prevId && !String(prevId).startsWith('folders:')) {
                const backBtn = document.createElement('button');
                backBtn.textContent = '‚Üê Volver al objeto';
                backBtn.style.marginLeft = '12px';
                backBtn.onclick = (e) => {
                e.preventDefault();
                historyStack.push(prevId);
                render();
                };
                bc.appendChild(backBtn);
            }
        }
        
        /**
         * Renders the complete focus view for a specific node. Organizes related
         * nodes into predecessor and successor groups by layer, handles group
         * expansion, creates the appropriate layout, renders all visual elements, and
         * configures the legend. Requests additional import information and handles
         * the functionality of the layer slider.
         *
         * @param {string} focusNodeId - ID of the container node to focus on
         * @param {string} currentId - Current navigation ID (can be a specific member)
         */
        function renderFocusView(focusNodeId, currentId) {
            try {
                mainLayer.innerHTML = '';

                if (focusedContainerId !== focusNodeId) {
                    expandedGroupIds.clear();
                    focusedContainerId = focusNodeId;
                }

                const { nodesToRender, edgesToRender } = getFocusedNeighborhoodData(focusNodeId);
                const focusNode = nodeMap.get(focusNodeId);
                if (!focusNode) return;

                const groups = { predecessors: {}, successors: {} };
                const layerDisplayInfo = {
                    view: { label: t('overview.views'), icon: 'üì±' },
                    state: { label: t('overview.state'), icon: 'üß†' },
                    service: { label: t('overview.service'), icon: 'üåê' },
                    model: { label: t('overview.model'), icon: 'üì¶' },
                    utility: { label: t('overview.utility'), icon: 'üõ†Ô∏è' },
                    member: { label: t('overview.members'), icon: 'üß©' }
                };

                // Process predecessors (normal graph connections)
                nodesToRender.forEach(node => {
                    if (node.id === focusNodeId || node.parent) return;

                    const isPredecessor = edgesToRender.some(e => getContainerId(e.source) === node.id && getContainerId(e.target) === focusNodeId);
                    const isSuccessor = edgesToRender.some(e => getContainerId(e.source) === focusNodeId && getContainerId(e.target) === node.id);
                    const groupType = isPredecessor ? 'predecessors' : (isSuccessor ? 'successors' : null);
                    if (!groupType) return;

                    const layer = node.data.layer || 'utility';
                    if (!groups[groupType][layer]) {
                        groups[groupType][layer] = { id: `group-${layer}-${groupType}`, kind: 'group', layer, nodes: [] };
                    }
                    groups[groupType][layer].nodes.push(node);
                });

                // Save data for when imports arrive
                lastFocusData = {
                    focusNode,
                    groups,
                    edgesToRender,
                    currentId,
                    focusNodeId,
                    layerDisplayInfo
                };

                // Create grouped nodes only for predecessors (initially)
                const predecessorNodes = [];
                Object.values(groups.predecessors).forEach(group => {
                    if (expandedGroupIds.has(group.id)) {
                        predecessorNodes.push(...group.nodes);
                    } else {
                        const label = `${layerDisplayInfo[group.layer]?.label || group.layer} (${group.nodes.length})`;
                        predecessorNodes.push({ ...group, label });
                    }
                });

                 // Initial layout with only predecessors (successors come later)
                const initialLayout = calculateFocusLayout(focusNode, predecessorNodes, []);

                // Create SVG layers
                const edgeLayer = createSvgElement('g', { class: 'edge-layer' });
                const nodeLayer = createSvgElement('g', { class: 'node-layer' });
                mainLayer.appendChild(edgeLayer);
                mainLayer.appendChild(nodeLayer);

                renderExpandedContainer(focusNode, initialLayout, false, currentId, true); // shellOnly=true
            
                predecessorNodes.forEach(node => {
                    if (node.kind === 'group') {
                        renderGroupNode(node, initialLayout);
                    } else {
                        renderCollapsedContainer(node, initialLayout);
                    }
                });

                Object.entries(groups.predecessors).forEach(([layer, group]) => {
                    const isCollapsed = !expandedGroupIds.has(group.id);
                    if (isCollapsed) {
                        edgesToRender.push({
                            id: `edge-${group.id}-to-${focusNodeId}`,
                            source: group.id,
                            target: focusNodeId,
                            kind: 'group-to-focus',
                            isVirtual: true
                        });
                    }
                });

                renderAggregatedEdgesForFocusView(edgesToRender, initialLayout, edgeLayer);
                
                const visibleNodeKinds = new Set();

                visibleNodeKinds.add(focusNode.kind);

                const focusMembers = allGraphNodes.filter(n => n.parent === focusNode.id);
                focusMembers.forEach(member => {
                    if (member && member.kind) {
                        visibleNodeKinds.add(member.kind);
                    }
                });

                predecessorNodes.forEach(node => {
                    if (node && node.kind) {
                        visibleNodeKinds.add(node.kind);
                        if (node.kind === 'group' && node.nodes) {
                            node.nodes.forEach(innerNode => {
                                if (innerNode && innerNode.kind) {
                                    visibleNodeKinds.add(innerNode.kind);
                                }
                            });
                        }
                    }
                });

                vscodeApi.postMessage({
                    command: 'log',
                    args: [`[DEBUG renderFocusView] Visible types: ${Array.from(visibleNodeKinds).join(', ')}`]
                });

                const visibleEdgeLabels = new Set(edgesToRender.map(e => e.label).filter(Boolean));

                renderLegend(svg, visibleNodeKinds, visibleEdgeLabels);
               
                autoFit(svg, mainLayer);
                showLayerSlider();
                initializeLayerSlider();
                vscodeApi.postMessage({
                    command: 'getImports',
                    nodeId: focusNodeId
                });

            } catch (e) {
                vscodeApi.postMessage({
                    command: 'log',
                    args: [`[WebView-ERROR] renderFocusView: ${e.message}`, `Stack: ${e.stack}`]
                });
            }
        }

         /**
         * Completes the rendering of the focus view after receiving import information.
         * Processes imports by classifying them into external and custom packages, integrates this
         * information with previous focus data, calculates the final layout including all
         * elements, and renders the complete view with nodes, edges, and an updated legend.
         *
         * @param {string} nodeId - ID of the focus node
         * @param {Array<string>} imports - Array of imported package names
         */
        function finishRenderingFocusView(nodeId, imports) {
            if (!nodeId && lastFocusData && lastFocusData.focusNodeId) {
                nodeId = lastFocusData.focusNodeId;
            }

            if (!nodeId || !lastFocusData || lastFocusData.focusNode.id !== nodeId) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[WebView-ERROR] No matching lastFocusData for nodeId: ${nodeId}`] 
                });
                return;
            }

            const { focusNode, groups, edgesToRender, currentId, layerDisplayInfo } = lastFocusData;

            try {
                const packageGroups = { external_packages: [], custom_packages: [] };

                const externalGroupId = 'group-external_packages-imports';
                const customGroupId = 'group-custom_packages-imports';
                
                if (imports && imports.length > 0) {
                    imports.forEach(pkgName => {
                        const pkgNodeId = `package_container:${pkgName}`;
                        const pkgNode = nodeMap.get(pkgNodeId);
                        if (pkgNode) {
                            const isExternal = pkgNode.data?.source?.packageType && 
                                            pkgNode.data.source.packageType !== 'custom'; 
                            
                            if (isExternal) {
                                packageGroups.external_packages.push(pkgNode); 
                            } else {
                                packageGroups.custom_packages.push(pkgNode); 
                            }
                        }
                    });
                }

                const predecessorNodes = [];
                Object.values(groups.predecessors).forEach(group => {
                    if (expandedGroupIds.has(group.id)) {
                        predecessorNodes.push(...group.nodes);
                    } else {
                        const label = `${layerDisplayInfo[group.layer]?.label || group.layer} (${group.nodes.length})`;
                        predecessorNodes.push({ ...group, label });
                    }
                });

                const successorNodes = [];
                Object.values(groups.successors).forEach(group => {
                    if (expandedGroupIds.has(group.id)) {
                        successorNodes.push(...group.nodes);
                    } else {
                        const label = `${layerDisplayInfo[group.layer]?.label || group.layer} (${group.nodes.length})`;
                        successorNodes.push({ ...group, label });
                    }
                });

                const packageNodes = [];
                
                if (packageGroups.external_packages.length > 0) {
                    if (expandedGroupIds.has(externalGroupId)) {
                        packageNodes.push(...packageGroups.external_packages);
                    } else {
                        packageNodes.push({
                            id: externalGroupId,
                            kind: 'group',
                            layer: 'external_packages',
                            label: t('packages.developed', packageGroups.external_packages.length),
                            nodes: packageGroups.external_packages,
                            fixedPosition: 'top'  
                        });
                    }
                } else {
                    
                    packageNodes.push({
                        id: externalGroupId + '_placeholder',
                        kind: 'placeholder',
                        layer: 'external_packages',
                        label: '',
                        nodes: [],
                        fixedPosition: 'top',
                        invisible: true
                    });
                }
                
                if (packageGroups.custom_packages.length > 0) {
                    if (expandedGroupIds.has(customGroupId)) {
                        packageNodes.push(...packageGroups.custom_packages);
                    } else {
                        packageNodes.push({
                            id: customGroupId,
                            kind: 'group',
                            layer: 'custom_packages',
                            label: t('packages.consumed', packageGroups.custom_packages.length),
                            nodes: packageGroups.custom_packages,
                            fixedPosition: 'bottom'
                        });
                    }
                } else {
                    packageNodes.push({
                        id: customGroupId + '_placeholder',
                        kind: 'placeholder',
                        layer: 'custom_packages',
                        label: '',
                        nodes: [],
                        fixedPosition: 'bottom',
                        invisible: true
                    });
                }

                const allSuccessors = [...successorNodes, ...packageNodes];

                const finalLayout = calculateFocusLayout(focusNode, predecessorNodes, allSuccessors);

                mainLayer.innerHTML = '';
                const edgeLayer = createSvgElement('g', { class: 'edge-layer' });
                const nodeLayer = createSvgElement('g', { class: 'node-layer' });
                mainLayer.appendChild(edgeLayer);
                mainLayer.appendChild(nodeLayer);

                renderExpandedContainer(focusNode, finalLayout, false, currentId, false);

                const otherNodes = [...predecessorNodes, ...allSuccessors];
                otherNodes.forEach(node => {
                    if (node.invisible) return;
                    
                    let renderedEl = null;
                    if (node.kind === 'group') {
                        renderedEl = renderGroupNode(node, finalLayout);
                    } else if (node.kind === 'package_container') {
                        renderedEl = renderCollapsedContainer(node, finalLayout);
                    } else {
                        renderedEl = renderCollapsedContainer(node, finalLayout);
                    }
                });

                ['predecessors', 'successors'].forEach(direction => {
                    Object.entries(groups[direction]).forEach(([layer, group]) => {
                        const isCollapsed = !expandedGroupIds.has(group.id);
                        if (isCollapsed) {
                            edgesToRender.push({
                                id: `edge-${group.id}-to-${nodeId}`,
                                source: direction === 'predecessors' ? group.id : nodeId,
                                target: direction === 'predecessors' ? nodeId : group.id,
                                kind: 'group-to-focus',
                                isVirtual: true
                            });
                        }
                    });
                });

                if (packageGroups.external_packages.length > 0) {
                    if (expandedGroupIds.has(externalGroupId)) {
                        packageGroups.external_packages.forEach(pkg => {
                            edgesToRender.push({
                                id: `edge-${pkg.id}-to-${nodeId}`, source: nodeId, target: pkg.id, isVirtual: true
                            });
                        });
                    } else {
                        edgesToRender.push({
                            id: `edge-${externalGroupId}-to-${nodeId}`, source: nodeId, target: externalGroupId, isVirtual: true
                        });
                    }
                }
                
                if (packageGroups.custom_packages.length > 0) {
                    if (expandedGroupIds.has(customGroupId)) {
                        packageGroups.custom_packages.forEach(pkg => {
                            edgesToRender.push({
                                id: `edge-${pkg.id}-to-${nodeId}`, source: nodeId, target: pkg.id, isVirtual: true
                            });
                        });
                    } else {
                        edgesToRender.push({
                            id: `edge-${customGroupId}-to-${nodeId}`, source: nodeId, target: customGroupId, isVirtual: true
                        });
                    }
                }
                const allNodesForLegend = [focusNode, ...predecessorNodes, ...allSuccessors];
                const visibleNodeKinds = new Set();

                allNodesForLegend.forEach(node => {
                    if (node && node.kind) {
                        visibleNodeKinds.add(node.kind);
                        
                        vscodeApi.postMessage({
                            command: 'log',
                            args: [`[DEBUG] Nodo: ${node.label} - Tipo: ${node.kind}`]
                        });
                    }
                    
                    if (node.kind === 'group' && node.nodes && Array.isArray(node.nodes)) {
                        node.nodes.forEach(innerNode => {
                            if (innerNode && innerNode.kind) {
                                visibleNodeKinds.add(innerNode.kind);
                                vscodeApi.postMessage({
                                    command: 'log',
                                    args: [`[DEBUG] Node: ${innerNode.label} - Type: ${innerNode.kind}`]
                                });
                            }
                        });
                    }
                });

                const focusMembers = allGraphNodes.filter(n => n.parent === focusNode.id);
                focusMembers.forEach(member => {
                    if (member && member.kind) {
                        visibleNodeKinds.add(member.kind);
                        vscodeApi.postMessage({
                            command: 'log',
                            args: [`[DEBUG] Focus member: ${member.label} - Type: ${member.kind}`]
                        });
                    }
                });
                edgesToRender.forEach(edge => {
                    const sourceNode = nodeMap.get(edge.source);
                    const targetNode = nodeMap.get(edge.target);
                    
                    if (sourceNode && sourceNode.kind) {
                        visibleNodeKinds.add(sourceNode.kind);
                    }
                    if (targetNode && targetNode.kind) {
                        visibleNodeKinds.add(targetNode.kind);
                    }
                });

                vscodeApi.postMessage({
                    command: 'log',
                    args: [`[DEBUG] All kinds captured: ${Array.from(visibleNodeKinds).join(', ')}`]
                });

                const visibleEdgeLabels = new Set(edgesToRender.map(e => e.label));

                renderAggregatedEdgesForFocusView(edgesToRender, finalLayout, edgeLayer);
                renderDetailedEdgesForFocusView(edgesToRender, finalLayout, edgeLayer);
                
                ensureFocusActionsBarForFolders(focusNode);
                autoFit(svg, mainLayer);

                lastFocusData = null;

            } catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[WebView-ERROR] Failure in finishRenderingFocusView: ${e.message}`, `Stack: ${e.stack}`] 
                });
            }
        }
        
        /**
         * Calculates the specific layout for the focus view by organizing nodes into
         * strategic positions. Places the focus node in the center, predecessors in columns
         * to the left, normal successors in columns to the right, and imports in rows
         * above and below. Handles automatic grouping when there are many elements.
         *
         * @param {Object} focusNode - Central focus node
         * @param {Array<Object>} predecessors - Array of predecessor nodes
         * @param {Array<Object>} successors - Array of successor nodes and imports
         * @returns {Map} Map with positions of all nodes
         */
        function calculateFocusLayout(focusNode, predecessors, successors) {
            try{
                const layout = new Map();
                const nodeWidth = 220;
                const nodeHeight = 40;
                const xSpacing = 400; // Horizontal space for predecessors/successors
                const ySpacing = 120; // Vertical space between focus and imports
                const maxItemsPerColumn = 4;
                
                if (!focusNode) return layout;

                const positionColumn = (nodes, xPos) => {
                    if (!nodes || nodes.length === 0) return;
                    const totalHeight = (nodes.length * nodeHeight) + (nodes.length - 1) * 50;
                    let currentY = -totalHeight / 2;
                    nodes.forEach(node => {
                        layout.set(node.id, { x: xPos, y: currentY + nodeHeight / 2, width: nodeWidth, height: nodeHeight });
                        currentY += nodeHeight + 50;
                    });
                };

                const positionRow = (nodes, yPos) => {
                    if (!nodes || nodes.length === 0) return;
                    const totalWidth = (nodes.length * nodeWidth) + (nodes.length - 1) * 50;
                    let currentX = -totalWidth / 2;
                    nodes.forEach(node => {
                        layout.set(node.id, { x: currentX + nodeWidth / 2, y: yPos, width: nodeWidth, height: nodeHeight });
                        currentX += nodeWidth + 50;
                    });
                };

                const focusNodeHeight = 80 + allGraphNodes.filter(m => m.parent === focusNode.id).length * 38;
                layout.set(focusNode.id, { x: 0, y: 0, width: nodeWidth + 40, height: focusNodeHeight });
                
                
                const normalSuccessors = [];
                const externalImports = [];
                const customImports = [];
                
                successors.forEach(node => {
                    if (node.kind === 'package_container' || node.layer === 'external_packages' || node.layer === 'custom_packages') {
                        
                        const isExternal = node.data?.source?.packageType && node.data.source.packageType !== 'custom';
                        if (isExternal || node.layer === 'external_packages') {
                            externalImports.push(node);
                        } else {
                            customImports.push(node);
                        }
                    } else {
                       
                        normalSuccessors.push(node);
                    }
                });

                for (let i = 0; i < predecessors.length; i += maxItemsPerColumn) {
                    const chunk = predecessors.slice(i, i + maxItemsPerColumn);
                    positionColumn(chunk, -xSpacing * (Math.floor(i / maxItemsPerColumn) + 1));
                }

                for (let i = 0; i < normalSuccessors.length; i += maxItemsPerColumn) {
                    const chunk = normalSuccessors.slice(i, i + maxItemsPerColumn);
                    positionColumn(chunk, xSpacing * (Math.floor(i / maxItemsPerColumn) + 1));
                }

                for (let i = 0; i < customImports.length; i += maxItemsPerColumn) {
                    const chunk = customImports.slice(i, i + maxItemsPerColumn);
                    const rowOffset = Math.floor(i / maxItemsPerColumn);
                    positionRow(chunk, -(focusNodeHeight / 2) - ySpacing - (rowOffset * (nodeHeight + 30)));
                }

                for (let i = 0; i < externalImports.length; i += maxItemsPerColumn) {
                    const chunk = externalImports.slice(i, i + maxItemsPerColumn);
                    const rowOffset = Math.floor(i / maxItemsPerColumn);
                    positionRow(chunk, (focusNodeHeight / 2) + ySpacing + (rowOffset * (nodeHeight + 30)));
                }

                return layout;
            } catch (e) {
                vscodeApi.postMessage({ command: 'log', args: [`[WebView-ERROR] Critical failure in calculateFocusLayout: ${e.message}`, `Stack: ${e.stack}`] });
                return new Map();
            }
        }

        /**
         * Ensures that the actions bar for folder-related functionalities
         * exists in the focus view. Creates a button that allows navigating to the
         * corresponding folder view of the current focus node, extracting the folder
         * path from the node's file URI.
         *
         * @param {Object} focusNode - Focus node for which to create the actions
         */
        function ensureFocusActionsBarForFolders(focusNode) {
            if (FOLDERS_DISABLED) return; 
            let bar = document.getElementById('focus-actions');
            if (!bar) {
                bar = document.createElement('div');
                bar.id = 'focus-actions';
                bar.style.display = 'flex';
                bar.style.gap = '8px';
                bar.style.alignItems = 'center';
                bar.style.margin = '8px 0';
                const host = document.getElementById('breadcrumb') || document.body;
                host.parentNode.insertBefore(bar, host.nextSibling);
            }
            bar.innerHTML = '';

            const btnFolders = document.createElement('button');
            btnFolders.textContent = 'üìÅ Ver carpetas';
            btnFolders.onclick = (e) => {
                e.preventDefault();
                const pathParts = getFolderPathPartsFromNode(focusNode);
                folderDrill = { focusId: focusNode.id, pathParts };
                historyStack.push(`folders:${pathParts.join('/') || '.'}`);
                render();
            };
            bar.appendChild(btnFolders);
        }

        /**
         * Extracts the parts of the folder path from a node's URI. Looks for
         * 'features' or 'lib' directories as reference points and constructs the
         * relative path excluding the file name. Used for folder navigation.
         *
         * @param {Object} node - Node from which to extract the folder path
         * @returns {Array<string>} Array of parts of the folder path
         */
        function getFolderPathPartsFromNode(node) {
            const file = node?.data?.fileUri || '';
            const parts = file.split('/');

            const iFeat = parts.indexOf('features');
            if (iFeat !== -1 && iFeat + 1 < parts.length) {
                const take = parts.slice(iFeat, parts.length - 1); // without .dart
                return take.filter(Boolean);
            }

            const iLib = parts.indexOf('lib');
            if (iLib !== -1) {
                const take = parts.slice(iLib, parts.length - 1);
                return take.filter(Boolean);
            }

            return []; 
        }

        /**
         * Renders a container in a collapsed state as a simple pill. Handles
         * special cases for navigable folder containers and sets up click
         * events for navigation. Creates a minimal visual representation of the node
         * without showing its internal members.
         *
         * @param {Object} node - Node to render as a collapsed container
         * @param {Object} layout - Layout object with node positions
         * @returns {SVGElement|null} The container's SVG element or null if there's an error
         */
        function renderCollapsedContainer(node, layout) {
            
            if (node.canNavigateDown && node.folderPath) {
                return renderNavigableFolderContainer(node, layout);
            }
            
            
            vscodeApi.postMessage({ 
                command: 'log', 
                args: [`[DEBUGGER] ‚û°Ô∏è Drawing COLLAPSED: ${node.label} (kind: ${node.kind})`] 
            });
            
            try {
                const nodeLayout = layout.get(node.id);
                if (!nodeLayout) return null;

                const group = createSvgElement('g', {
                    'transform': `translate(${nodeLayout.x}, ${nodeLayout.y})`,
                    'class': 'node',
                    'data-id': node.id
                });
                
                renderPill(node, group, 0, nodeLayout.width);

                if (node.kind !== 'folder-center') {
                    group.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const containerId = getContainerId(node.id);
                        if (historyStack[historyStack.length - 1] !== containerId) {
                            historyStack.push(containerId);
                            render();
                        }
                    });
                } else {
                    group.style.cursor = 'default';
                }

                const nodeLayer = mainLayer.querySelector('.node-layer');
                if (nodeLayer) {
                    nodeLayer.appendChild(group);
                }
                
                return group;

            } catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[WebView-ERROR] Failure in renderCollapsedContainer: ${e.message}`] 
                });
                return null;
            }
        }
        
        /**
         * Draws a container node (like a class) in its expanded state,
         * showing all its members (fields and methods) as "pills" inside.
         * @param {ProjectGraphNode} node - The container node to draw.
         * @param {Map} layout - The layout map with positions and sizes.
         * @param {boolean} returnOnly - (Not currently used) If true, just returns the element without adding it to the SVG.
         * @param {string | null} highlightedMemberId - The ID of a specific member that should be highlighted.
         * @returns {SVGElement | null} The created SVG group element.
         */
        function renderExpandedContainer(node, layout, returnOnly = false, highlightedMemberId = null, shellOnly = false) {
            vscodeApi.postMessage({ command: 'log', args: [`[DEBUGGER] ‚û°Ô∏è Drawing EXPANDED: ${node.label} (kind: ${node.kind})`] });
            
            vscodeApi.postMessage({ 
            command: 'log', 
            args: [
                `[renderExpandedContainer] Focus: ${node.label} (${node.id})`,
                `Member found:`,
                allGraphNodes
                .filter(n => n.parent === node.id)
                .map(n => ({ id: n.id, label: n.label }))
            ]
            });

            try {

                const nodeLayout = layout.get(node.id);
                if (!nodeLayout) {
                    console.error(`Layout not found for container: ${node.id}`);
                    return null;
                }

                const group = createSvgElement('g', {
                    class: `node node-container-class expanded color-${node.data?.layer || 'default'}`,
                    transform: `translate(${nodeLayout.x}, ${nodeLayout.y})`,
                    'data-id': node.id
                });

                const rect = createSvgElement('rect', {
                    class: 'node-rect',
                    x: -(nodeLayout.width + 50) / 2,
                    y: -nodeLayout.height / 2,
                    width: nodeLayout.width + 50,
                    height: nodeLayout.height
                });

                const headerText = createSvgElement('text', {
                    class: 'class-header',
                    x: -nodeLayout.width / 2 + 20,
                    y: -nodeLayout.height / 2 + 25
                });
                headerText.textContent = node.label;

                const divider = createSvgElement('line', {
                    class: 'section-divider',
                    x1: -nodeLayout.width / 2 + 10,
                    x2: nodeLayout.width / 2 - 10,
                    y1: -nodeLayout.height / 2 + 45,
                    y2: -nodeLayout.height / 2 + 45
                });

                group.appendChild(rect);
                group.appendChild(headerText);
                group.appendChild(divider);


                if (!shellOnly) {
                    const children = allGraphNodes.filter(n => n.parent === node.id);
                    
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [
                            `[renderExpandedContainer] Rendering ${children.length} members for ${node.label}`,
                            'Member details:',
                            children.map(m => ({
                                label: m.label,
                                kind: m.kind,
                                id: m.id
                            }))
                        ]
                    });

                   
                    const memberHeight = 38;
                    const startY = -nodeLayout.height / 2 + 60;

                    children.forEach((member, index) => {
                        const memberY = startY + (index * memberHeight);
                        
                        vscodeApi.postMessage({ 
                            command: 'log', 
                            args: [`[DEBUG] Rendering pill for: ${member.label} (${member.kind})`]
                        });
                        
                        const pill = renderPill(member, group, memberY, nodeLayout.width * 0.9);
                        
                        if (pill && member.id === highlightedMemberId) {
                            pill.classList.add('focused-member');
                        }
                    });
                }

                const children = allGraphNodes.filter(n => n.parent === node.id);
                children.forEach(member => {
                    const memberLayout = layout.get(member.id);
                    if (!memberLayout) {
                        vscodeApi.postMessage({ command: 'log', args: [`‚ö†Ô∏è Layout not found for member: ${member.id}`] });
                        return;
                    }

                    const relativeY = memberLayout.y - nodeLayout.y;
                    const pill = renderPill(member, group, relativeY, nodeLayout.width * 0.9);

                    if (pill && member.id === highlightedMemberId) {
                        pill.classList.add('focused-member');
                    }
                });

                group.addEventListener('dblclick', (e) => {
                    e.stopPropagation();

                    if (node.data?.selectionRange && Array.isArray(node.data.selectionRange)) {
                        startPos = node.data.selectionRange[0];
                        endPos = node.data.selectionRange[1];
                    } else if (node.data?.range && Array.isArray(node.data.range)) {
                        startPos = node.data.range[0];
                        endPos = node.data.range[1];
                    } else if (node.data?.selectionRange) {
                        startPos = node.data.selectionRange.start;
                        endPos = node.data.selectionRange.end;
                    } else if (node.data?.range) {
                        startPos = node.data.range.start;
                        endPos = node.data.range.end;
                    }
                    if (node?.data?.fileUri && node?.data?.selectionRange) {
                        vscodeApi.postMessage({
                            command: 'openClass',
                            file: node.data.fileUri,
                            start: startPos,
                            end: endPos
                        });
                    }
                });

                const nodeLayer = mainLayer.querySelector('.node-layer');
                if (nodeLayer) {
                    nodeLayer.appendChild(group);
                } else {
                    vscodeApi.postMessage({ command: 'log', args: ['‚ùå Could not find .node-layer to insert the group.'] });
                }

                return group;

            } catch (e) {
                vscodeApi.postMessage({
                    command: 'log',
                    args: [`[WebView-ERROR] Failure in renderExpandedContainer: ${e.message}`, `Stack: ${e.stack}`]
                });
                return null;
            }
        }
    
        /**
         * Returns the highest priority label from a set of labels.
         * @param {Set<string>} labels - A set of labels like 'CALLS', 'READS_FROM'.
         * @returns {string} The highest priority label.
         */
        function getPriorityLabel(labels) {
            const priority = ['EXTENDS', 'IMPLEMENTS', 'CALLS', 'WRITES_TO', 'READS_FROM', 'INSTANCE_OF', 'USES_AS_TYPE'];
            for (const p of priority) {
                if (labels.has(p)) {
                    return p;
                }
            }
            return 'unknown'; // Fallback
        }
        
        /**
         * Renders aggregated edges for the focus view with appropriate horizontal and vertical
         * curves. Detects import connections (vertical) versus normal connections (horizontal),
         * calculates connection points based on node geometry, and applies specific
         * arrow markers. Prevents edge duplication by tracking unique keys.
         *
         * @param {Array<Object>} edges - Array of edges to render
         * @param {Object} layout - Layout object with node positions
         * @param {SVGElement} layer - SVG layer where to render the edges
         */
        function renderAggregatedEdgesForFocusView(edges, layout, layer) {
            if (!edges || !layout || !layer) return;
            const seen = new Set();

            
            const calculateHorizontalCurve = (source, target) => {
                const dx = target.x - source.x;
                const controlOffset = Math.min(Math.abs(dx) * 0.3, 80);
                return `M ${source.x} ${source.y} C ${source.x + controlOffset} ${source.y}, ${target.x - controlOffset} ${target.y}, ${target.x} ${target.y}`;
            };

            const calculateVerticalCurve = (source, target) => {
                const dy = target.y - source.y;
                const controlOffset = Math.min(Math.abs(dy) * 0.3, 60);
                return `M ${source.x} ${source.y} C ${source.x} ${source.y + controlOffset}, ${target.x} ${target.y - controlOffset}, ${target.x} ${target.y}`;
            };

            edges.forEach(edge => {
                const sourceId = getContainerId(edge.source);
                const targetId = getContainerId(edge.target);
                const key = `${sourceId}->${targetId}`;
                if (seen.has(key)) return;
                seen.add(key);

                const sourceLayout = layout.get(sourceId);
                const targetLayout = layout.get(targetId);
                if (!sourceLayout || !targetLayout) return;

                let pathData;
                let sourcePoint, targetPoint;

                const focusNodeLayout = layout.get(lastFocusData?.focusNode?.id);
                const isImportConnection = focusNodeLayout && (
                    (targetLayout.y < focusNodeLayout.y - 50) || 
                    (targetLayout.y > focusNodeLayout.y + 50)   
                );

                if (isImportConnection) {
                    
                    const isTargetAbove = targetLayout.y < sourceLayout.y;
                    
                    if (isTargetAbove) {
                        
                        sourcePoint = { 
                            x: sourceLayout.x, 
                            y: sourceLayout.y - sourceLayout.height / 2 
                        };
                        targetPoint = { 
                            x: targetLayout.x, 
                            y: targetLayout.y + targetLayout.height / 2 
                        };
                    } else {
                        
                        sourcePoint = { 
                            x: sourceLayout.x, 
                            y: sourceLayout.y + sourceLayout.height / 2 
                        };
                        targetPoint = { 
                            x: targetLayout.x, 
                            y: targetLayout.y - targetLayout.height / 2 
                        };
                    }
                    
                    pathData = calculateVerticalCurve(sourcePoint, targetPoint);
                } else {
                    
                    if (Math.abs(targetLayout.x - sourceLayout.x) > Math.abs(targetLayout.y - sourceLayout.y)) {
                       
                        sourcePoint = { x: sourceLayout.x + sourceLayout.width / 2, y: sourceLayout.y };
                        targetPoint = { x: targetLayout.x - targetLayout.width / 2, y: targetLayout.y };
                        pathData = calculateHorizontalCurve(sourcePoint, targetPoint);
                    } else {
                        
                        const isTargetAbove = targetLayout.y < sourceLayout.y;
                        sourcePoint = { x: sourceLayout.x, y: isTargetAbove ? sourceLayout.y - sourceLayout.height / 2 : sourceLayout.y + sourceLayout.height / 2 };
                        targetPoint = { x: targetLayout.x, y: isTargetAbove ? targetLayout.y + targetLayout.height / 2 : targetLayout.y - targetLayout.height / 2 };
                        pathData = calculateVerticalCurve(sourcePoint, targetPoint);
                    }
                }
                
                const labelClass = (edge.label || 'unknown').toLowerCase().replace(/_/g, '-');
                
               
                let markerEnd = '';
                
                if (edge.isVirtual || edge.kind === 'group-to-focus') {
                    if (!isImportConnection) {
                       
                        markerEnd = 'url(#arrow-group-to-focus)';
                    }
                    
                } else {
                    
                    markerEnd = `url(#arrow-${labelClass})`;
                }
                
                const path = createSvgElement('path', {
                    d: pathData,
                    class: `edge-path aggregated-edge ${labelClass} ${edge.isVirtual ? 'edge-virtual' : ''}`,
                    'marker-end': markerEnd,
                    'data-aggregation-key': key
                });
                layer.appendChild(path);
            });
        }

        /**
         * Renders detailed edges for the focus view with staggered curves when
         * there are multiple connections between the same containers. Groups edges by endpoints,
         * calculates vertical offsets to avoid overlap, and creates dynamic markers
         * oriented according to the curve's angle.
         *
         * @param {Array<Object>} edges - Array of detailed edges to render
         * @param {Object} layout - Layout object with node positions
         * @param {SVGElement} layer - SVG layer where to render the edges
         */
        function renderDetailedEdgesForFocusView(edges, layout, layer) {
            const edgeGroups = {}; 

            edges.forEach(edge => {
                if (edge.isVirtual) return;

                const sourceContainer = getContainerId(edge.source);
                const targetContainer = getContainerId(edge.target);
                if(sourceContainer === targetContainer) return;
                
                const aggregationKey = `${sourceContainer}->${targetContainer}`;

                const staggerKey = `${edge.source}->${edge.target}`;
                if (!edgeGroups[staggerKey]) edgeGroups[staggerKey] = [];
                edgeGroups[staggerKey].push({edge: edge, key: aggregationKey});
            });

            Object.values(edgeGroups).forEach(group => {
                group.forEach(({edge, key}, index) => {
                    const sourceLayout = layout.get(edge.source);
                    const targetLayout = layout.get(edge.target);
                    if (!sourceLayout || !targetLayout) return;
                    
                    const sourceNode = nodeMap.get(edge.source);
                    const isSourceLeaf = sourceNode?.kind && sourceNode.kind !== 'class' && sourceNode.kind !== 'enum';
                    const staggerEndpoint = isSourceLeaf ? 'source' : 'target';

                    const curveResult = calculateCurve(sourceLayout, targetLayout, index, group.length, staggerEndpoint);
                    const labelClass = edge.label ? edge.label.toLowerCase().replace(/_/g, '-') : 'unknown';
                    const uniqueMarkerId = `arrow-${labelClass}-${Math.round(curveResult.angle)}`;
                    ensureDynamicMarker(svg, uniqueMarkerId, type.color, curveResult.angle);
                    const path = createSvgElement('path', {
                        'd': curveResult.path,
                        'class': `edge-path detailed-edge ${labelClass}`,
                        'marker-end': `url(#${uniqueMarkerId})`,
                        'data-aggregation-key': key, 
                        'data-source': edge.source, 
                        'data-target': edge.target,
                        'data-edge-key': `detail-${edge.id}`
                    });
                    layer.appendChild(path);
                });
            });
        }

        /**
         * Ensures that a dynamic SVG marker with a specific ID, color, and angle exists.
         * Creates the marker only if it does not already exist, avoiding duplication in the DOM.
         * Used for edge arrows with custom orientation based on the connection's direction.
         *
         * @param {SVGElement} svg - Root SVG element
         * @param {string} markerId - Unique ID of the marker
         * @param {string} color - Fill color of the marker
         * @param {number} angle - Orientation angle in degrees
         */
        function ensureDynamicMarker(svg, markerId, color, angle) {
            if (svg.querySelector(`#${markerId}`)) return;
            
            const defs = svg.querySelector('defs');
            const marker = createSvgElement('marker', {
                'id': markerId,
                'viewBox': '0 -3 8 6',
                'refX': 7,
                'refY': 0,
                'markerWidth': 4,
                'markerHeight': 4,
                'orient': `${angle}deg` 
            });
            
            const path = createSvgElement('path', {
                'd': 'M0,-3L8,0L0,3Z',
                'fill': color
            });
            
            marker.appendChild(path);
            defs.appendChild(marker);
        }

        /**
         * Calculates a B√©zier curve between two layouts with optional staggering for
         * multiple parallel edges. Determines connection points, applies vertical offsets
         * for visual separation, and calculates the final tangent angle for arrow
         * marker orientation.
         *
         * @param {Object} sourceLayout - Layout of the source node
         * @param {Object} targetLayout - Layout of the target node
         * @param {number} index - Index of the edge in a parallel group
         * @param {number} total - Total number of parallel edges
         * @param {string} staggerEndpoint - Endpoint to apply staggering ('source'|'target')
         * @returns {Object} Object with SVG path and arrow angle
         */
        function calculateCurve(sourceLayout, targetLayout, index, total, staggerEndpoint) {
            const isStaggered = index !== undefined && total > 1;
            let yOffset = 0;
            if (isStaggered) {
                const staggerHeight = staggerEndpoint === 'source' ? sourceLayout.height * 0.7 : targetLayout.height * 0.7;
                yOffset = -(staggerHeight / 2) + (staggerHeight / (total + 1)) * (index + 1);
            }
            
            const isLeftToRight = targetLayout.x > sourceLayout.x;

            const sourcePoint = {
                x: sourceLayout.x + (isLeftToRight ? sourceLayout.width / 2 : -sourceLayout.width / 2),
                y: sourceLayout.y + (staggerEndpoint === 'source' ? yOffset : 0)
            };
            const targetPoint = {
                x: targetLayout.x - (isLeftToRight ? targetLayout.width / 2 : -targetLayout.width / 2),
                y: targetLayout.y + (staggerEndpoint === 'target' ? yOffset : 0)
            };
            
            const dx = targetPoint.x - sourcePoint.x;
            const dy = targetPoint.y - sourcePoint.y;
            
            const controlOffset = Math.min(Math.abs(dx) * 0.4, 100);

            const cp2x = targetPoint.x - controlOffset;
            const cp2y = targetPoint.y - dy * 0.1;

            const tangentX = targetPoint.x - cp2x;
            const tangentY = targetPoint.y - cp2y;
            const angle = Math.atan2(tangentY, tangentX) * 180 / Math.PI;
            
            const pathData = `M ${sourcePoint.x} ${sourcePoint.y} C ${sourcePoint.x + controlOffset} ${sourcePoint.y + dy * 0.1}, ${cp2x} ${cp2y}, ${targetPoint.x} ${targetPoint.y}`;
            
            return {
                path: pathData,
                angle: angle
            };
        }

        /**
         * Finds all detailed edges connected to a specific node. Handles
         * both container nodes and member nodes, searching for connections where the node
         * is a direct source or target, or where its container is involved in the
         * connection. Filters duplicates from the result.
         *
         * @param {string} nodeId - ID of the node for which to find connections
         * @returns {Array<Object>} Array of edges connected to the node
         */
        function findConnectedDetailedEdges(nodeId) {
            const connected = [];
            const hoveredNode = nodeMap.get(nodeId);
            if (!hoveredNode) return [];

            const isContainer = !hoveredNode.parent;
            const effectiveId = hoveredNode.id;
            const containerId = getContainerId(effectiveId);

            allGraphEdges.forEach(edge => {
                const sourceContainer = getContainerId(edge.source);
                const targetContainer = getContainerId(edge.target);
                
                if (sourceContainer === targetContainer) return;

                if (isContainer) {
                    if (sourceContainer === containerId || targetContainer === containerId) {
                        connected.push(edge);
                    }
                } else {
                   
                    if (edge.source === effectiveId || edge.target === effectiveId) {
                        connected.push(edge);
                    }
                }
            });
            return [...new Set(connected)];
        }

        /**
         * Sets up all necessary SVG markers for the diagram's edges.
         * Creates predefined markers for different relationship types (extends,
         * implements, calls, etc.) with specific colors, as well as special
         * markers for virtual and default connections.
         *
         * @param {SVGElement} svg - Root SVG element to add definitions to
         */
        function setupMarkers(svg) {
            const defs = createSvgElement('defs');
            const defaultColor = '#adb5bd';

            const virtualMarker = createSvgElement('marker', {
                id: 'arrow-group-to-focus',
                viewBox: '0 -5 10 10',
                refX: 8,
                refY: 0,
                markerWidth: 6,
                markerHeight: 6,
                orient: 'auto'
            });
            const virtualPath = createSvgElement('path', {
                d: 'M0,-5L10,0L0,5',
                fill: '#8FCB9B' 
            });
            virtualMarker.appendChild(virtualPath);
            defs.appendChild(virtualMarker);


            const defaultMarker = createSvgElement('marker', {
                'id': `arrow-default`,
                'viewBox': '0 -5 10 10', 'refX': 8, 'refY': 0,
                'markerWidth': 6, 'markerHeight': 6, 'orient': '0'
            });
            const defaultPath = createSvgElement('path', { 'd': 'M0,-5L10,0L0,5', 'fill': defaultColor });
            defaultMarker.appendChild(defaultPath);
            defs.appendChild(defaultMarker);

            const markerTypes = [
                { id: 'extends', color: '#28a745' },      // Green for inheritance
                { id: 'implements', color: '#17a2b8' },   // Cyan for interfaces
                { id: 'calls', color: '#6f42c1' },       // Purple for calls
                { id: 'reads-from', color: '#fd7e14' },   // Orange for data reading
                { id: 'writes-to', color: '#dc3545' },    // Red for writing
                { id: 'instance-of', color: '#007bff' },  // Blue
                { id: 'uses-as-type', color: '#6c757d' }, // Gray
                { id: 'unknown', color: '#adb5bd' }      // Light gray for default
            ];

            markerTypes.forEach(type => {
                const marker = createSvgElement('marker', {
                    'id': `arrow-${type.id}`,
                    'viewBox': '0 -3 8 6',      // Smaller ViewBox
                    'refX': 7,                   // Adjusted reference point
                    'refY': 0,
                    'markerWidth': 4,            // Smaller marker
                    'markerHeight': 4,           // Smaller marker
                    'orient': '0'
                });
                const path = createSvgElement('path', { 
                    'd': 'M0,-3L8,0L0,3Z',      // Smaller, closed arrow with Z
                    'fill': type.color 
                });
                marker.appendChild(path);
                defs.appendChild(marker);
            });
            svg.appendChild(defs);
        }

        /**
         * Automatically adjusts the SVG view to show all content of the layer
         * with appropriate padding. Calculates the content's bounding box, determines the
         * necessary scale respecting minimum and maximum limits, and applies
         * translation and scale transformations to center and fit the content.
         *
         * @param {SVGElement} svg - Container SVG element
         * @param {SVGElement} layer - Layer with content to fit
         * @param {Object} options - Configuration options {padding, maxScale, minScale}
         */
        function autoFit(svg, layer, { padding = 40, maxScale = 2.5, minScale = 0.5 } = {}) {
            const bbox = layer.getBBox();
            const bw = Math.max(bbox.width, 1);
            const bh = Math.max(bbox.height, 1);
            const vw = svg.clientWidth  || svg.viewBox.baseVal.width  || 1;
            const vh = svg.clientHeight || svg.viewBox.baseVal.height || 1;

            const sx = (vw - 2 * padding) / bw;
            const sy = (vh - 2 * padding) / bh;
            let scale = Math.min(sx, sy);
            const unclamped = scale;
            scale = Math.max(minScale, Math.min(scale, maxScale));

            const cx = bbox.x + bw / 2;
            const cy = bbox.y + bh / 2;
            const tx = vw / 2 - scale * cx;
            const ty = vh / 2 - scale * cy;

            if (DEBUG_FIT) {
                debugLog('[AutoFit] vwxvh=', vw, vh,
                        '| bbox=', { x:bbox.x, y:bbox.y, w:bw, h:bh },
                        '| sx,sy=', sx.toFixed(3), sy.toFixed(3),
                        '| scale (raw‚Üíclamped)=', unclamped.toFixed(3), '‚Üí', scale.toFixed(3),
                        '| translate=', { tx: tx.toFixed(1), ty: ty.toFixed(1) });
                drawDebugBBox(svg, layer, '#00BCD4');
            }

            layer.setAttribute('transform', `translate(${tx}, ${ty}) scale(${scale})`);
        }

        /**
         * Creates an SVG element with the correct namespace and applies the specified attributes.
         * A fundamental utility function for constructing SVG elements in the DOM,
         * ensuring the appropriate namespace for correct rendering.
         *
         * @param {string} tag - Name of the SVG element to create
         * @param {Object} attrs - Object with attributes to apply to the element
         * @returns {SVGElement} The created SVG element with the applied attributes
         */
        function createSvgElement(tag, attrs = {}) {
            const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (const key in attrs) {
                el.setAttribute(key, attrs[key]);
            }
            return el;
        }

        /**
         * Clears all active highlights in the diagram and restores the default
         * visual state. Hides the tooltip, removes focus classes, hides detailed
         * edges, and shows aggregated edges. A global cleanup function to reset the view.
         */
        function clearAllHighlights() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip) tooltip.classList.remove('visible');

            const mainLayer = document.querySelector('.main-layer');
            if (!mainLayer) return;

            mainLayer.classList.remove('graph-unfocused');
            mainLayer.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));

            mainLayer.querySelectorAll('.detailed-edge').forEach(p => {
                p.classList.add('hidden');
                p.classList.remove('visible');
            });
            mainLayer.querySelectorAll('.aggregated-edge').forEach(p => {
                p.classList.remove('hidden'); 
                p.classList.add('visible');
            });
        }

        /**
         * Renders the diagram legend showing symbols for visible node types and
         * relationships. Analyzes the present node kinds and edge labels,
         * creates visual representations with appropriate colors, and organizes
         * the information into separate sections for symbols and relationships.
         *
         * @param {SVGElement} svgElement - SVG element to add the legend to
         * @param {Set<string>} visibleNodeKinds - Set of visible node kinds
         * @param {Set<string>} visibleEdgeLabels - Set of visible edge labels
         */
        function renderLegend(svgElement, visibleNodeKinds, visibleEdgeLabels) {
            const oldLegend = svgElement.querySelector('.legend');
            if (oldLegend) oldLegend.remove();
            
            const legendGroup = createSvgElement('g', { 'class': 'legend', 'transform': 'translate(15, 15)' });
            let currentY = 0;

            const legendDefinitions = {
                method: {
                    label: t('legend.responsibilities'),
                    color: '#FBE9A8',
                    kinds: ['method', 'function', 'constructor']
                },
                field: {
                    label: t('legend.attributes'),
                    color: 'var(--pill-field-bg)',
                    kinds: ['field', 'property']
                },
                primitive: {
                    label: t('legend.collaborators'),
                    color: 'var(--pill-primitive-bg)',
                    kinds: ['class', 'enum', 'mixin', 'extension', 'typedef', 'primitive', 'widget', 'model', 'package_container']
                },
                'grouped-members': {
                    label: t('legend.groupedObjects'),
                    color: '#28a745',
                    kinds: ['group', 'grouped-members']
                }
            };

            vscodeApi.postMessage({
                command: 'log',
                args: [`[DEBUG] visibleNodeKinds: ${Array.from(visibleNodeKinds).join(', ')}`]
            });

            const activeItems = [];
            
            for (const [legendKey, definition] of Object.entries(legendDefinitions)) {
                 const hasVisibleKind = definition.kinds.some(kind => visibleNodeKinds.has(kind));
                
                if (hasVisibleKind) {
                    activeItems.push({
                        key: legendKey,
                        label: definition.label,
                        color: definition.color
                    });
                }
            }

            vscodeApi.postMessage({
                command: 'log',
                args: [`[DEBUG] Active legend items: ${activeItems.map(i => i.label).join(', ')}`]
            });

            if (activeItems.length > 0) {
                const title = createSvgElement('text', { 
                    y: currentY + 15, 
                    'font-weight': 'bold', 
                    'font-size': '14px', 
                    'fill': '#212121' 
                });
                title.textContent = t('legend.symbols');
                legendGroup.appendChild(title);
                currentY += 30;

                activeItems.forEach(item => {
                    const itemGroup = createSvgElement('g', { transform: `translate(0, ${currentY})` });

                    const rect = createSvgElement('rect', {
                        x: 0,
                        y: -8,
                        width: 16,
                        height: 16,
                        rx: 3,
                        stroke: '#ccc',
                        fill: item.color
                    });

                    const text = createSvgElement('text', {
                        x: 25,
                        y: 0,
                        'dominant-baseline': 'middle',
                        'font-size': '14px',
                        'fill': '#212121'
                    });
                    text.textContent = item.label;

                    itemGroup.appendChild(rect);
                    itemGroup.appendChild(text);
                    legendGroup.appendChild(itemGroup);
                    currentY += 25;
                });
            }

            const edgeLegendItems = [
                { label: t('edge.extends'), edgeType: 'EXTENDS', class: 'extends' },
                { label: t('edge.implements'), edgeType: 'IMPLEMENTS', class: 'implements' },
                { label: t('edge.calls'), edgeType: 'CALLS', class: 'calls' },
                { label: t('edge.readsFrom'), edgeType: 'READS_FROM', class: 'reads-from' },
                { label: t('edge.writesTo'), edgeType: 'WRITES_TO', class: 'writes-to' }
            ];

            const activeEdgeItems = edgeLegendItems.filter(item => visibleEdgeLabels.has(item.edgeType));

            if (activeEdgeItems.length > 0) {
                currentY += 10;
                const title = createSvgElement('text', {
                    y: currentY + 15,
                    'font-weight': 'bold',
                    'font-size': '14px',
                    'fill': '#212121'
                });
                title.textContent = t('legend.relationships');
                legendGroup.appendChild(title);
                currentY += 30;

                activeEdgeItems.forEach(item => {
                    const strokeColor = getColorFromClass(item.class);
                    ensureArrowheadMarker(svgElement, item.class, strokeColor);

                    const itemGroup = createSvgElement('g', { transform: `translate(0, ${currentY})` });

                    const line = createSvgElement('line', {
                        x1: 0,
                        y1: 0,
                        x2: 22,
                        y2: 0,
                        'stroke-width': 2,
                        'stroke': strokeColor,
                        'marker-end': `url(#arrowhead-${item.class})`
                    });

                    const text = createSvgElement('text', {
                        x: 25,
                        y: 0,
                        'dominant-baseline': 'middle',
                        'font-size': '14px',
                        'font-weight': '400',
                        'fill': '#212121'
                    });
                    text.textContent = item.label;

                    itemGroup.appendChild(line);
                    itemGroup.appendChild(text);
                    legendGroup.appendChild(itemGroup);
                    currentY += 25;
                });
            }

            svgElement.appendChild(legendGroup);
        }

        /**
         * Gets the color associated with a specific edge class. Maps relationship
         * classes (calls, extends, implements, etc.) to predefined hexadecimal
         * colors for visual consistency in the diagram.
         *
         * @param {string} edgeClass - The CSS class of the edge
         * @returns {string} The hexadecimal color corresponding to the class
         */
        function getColorFromClass(edgeClass) {
            switch (edgeClass) {
                case 'calls': return '#6f42c1';
                case 'extends': return '#28a745';
                case 'implements': return '#17a2b8';
                case 'reads-from': return '#fd7e14';
                case 'writes-to': return '#dc3545';
                case 'instance-of': return '#007bff';
                case 'uses-as-type': return '#6c757d';
                case 'unknown': return '#adb5bd';
                default: return '#ccc';
            }
        }

        /**
         * Ensures an SVG arrowhead marker for a specific class and color exists.
         * Creates the marker only if it doesn't already exist, avoiding duplication. Used
         * for legend arrows with custom colors according to the relationship type.
         *
         * @param {SVGElement} svgElement - Root SVG element
         * @param {string} className - Class name for the marker
         * @param {string} color - Color of the marker
         */
        function ensureArrowheadMarker(svgElement, className, color) {
            const id = `arrowhead-${className}`;
            if (svgElement.querySelector(`#${id}`)) return;

            const defs = svgElement.querySelector('defs') || createSvgElement('defs');
            if (!svgElement.querySelector('defs')) svgElement.appendChild(defs);

            const marker = createSvgElement('marker', {
                id: id,
                viewBox: '0 0 10 10',
                refX: 10,
                refY: 5,
                markerWidth: 6,
                markerHeight: 6,
                orient: 'auto-start-reverse',
            });

            const path = createSvgElement('path', {
                d: 'M 0 0 L 10 5 L 0 10 z',
                fill: color,
                stroke: 'none'
            });

            marker.appendChild(path);
            defs.appendChild(marker);
        }

        /**
         * Gets the container ID of a given node. If the node has a parent, it returns
         * the parent's ID; otherwise, it returns the node's own ID. A utility
         * function for navigating the node hierarchy.
         *
         * @param {string} nodeId - The node's ID
         * @returns {string} The container node's ID
         */
        function getContainerId(nodeId) {
            const node = nodeMap.get(nodeId);
            return node?.parent || nodeId;
        }

       /**
         * Specifically clears hover highlights, restoring the normal visual state.
         * Removes focus classes, hides the tooltip, hides detailed edges,
         * and shows aggregated edges. Includes error handling for robustness.
         */
        function clearHoverHighlights() {
            try{
                mainLayer.classList.remove('graph-unfocused');
                mainLayer.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
                tooltip.classList.remove('visible');

                mainLayer.querySelectorAll('.detailed-edge.visible').forEach(p => {
                    p.classList.remove('visible');
                    p.classList.add('hidden');
                });
                mainLayer.querySelectorAll('.aggregated-edge.hidden').forEach(p => {
                    p.classList.remove('hidden');
                });
            }
            catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [
                        `[WebView-ERROR] Critical failure in clearHoverHighlights: ${e.message}`,
                        `Stack: ${e.stack}`
                    ]
                });
                
            }
        }


        /**
         * Starts a step-by-step animation along a path of nodes. Applies
         * pulse effects to the current node, highlights connected edges, and progresses
         * automatically with time intervals. When finished, it highlights the entire path.
         *
         * @param {Array<string>} path - Array of node IDs that form the path
         */
        function startAnimation(path) {
            let step = 0;
            const interval = 1500; // 1.5 seconds per step

            mainLayer.classList.remove('graph-unfocused');
            mainLayer.querySelectorAll('.highlight, .trace-active').forEach(el => el.classList.remove('highlight', 'trace-active'));

            function nextStep() {
                if (step >= path.length) {
                    path.forEach(nodeId => {
                        const nodeEl = mainLayer.querySelector(`[data-id='${getContainerId(nodeId)}']`);
                        if (nodeEl) nodeEl.classList.add('highlight');
                    });
                    return;
                }

                mainLayer.querySelectorAll('.trace-active').forEach(el => el.classList.remove('trace-active'));

                const currentNodeId = path[step];
                const containerId = getContainerId(currentNodeId);
                const nodeEl = mainLayer.querySelector(`g.node[data-id='${containerId}']`);

                if (nodeEl) {
                    nodeEl.classList.add('trace-active'); 
                }

                if (step > 0) {
                    const prevContainerId = getContainerId(path[step-1]);
                    let edgeEl = mainLayer.querySelector(`path.aggregated-edge[data-aggregation-key='${prevContainerId}->${containerId}']`);
                    if (!edgeEl) {
                    edgeEl = mainLayer.querySelector(`path.aggregated-edge[data-aggregation-key='${containerId}->${prevContainerId}']`);
                    }
                    if(edgeEl) edgeEl.classList.add('highlight');
                }

                step++;
                setTimeout(nextStep, interval);
            }

            nextStep();
        }

        /**
         * Animates the data flow along a specific path. If the initial node
         * is not in focus, it automatically navigates to it before starting the animation.
         * A high-level function that combines navigation and visual animation.
         *
         * @param {Array<string>} path - Array of node IDs representing the flow
         */
        function animateDataFlow(path) {
            if (!path || path.length === 0) return;

            const startNodeId = path[0];
            const contextId = getContainerId(startNodeId);

            if (focusedContainerId !== contextId) {
                historyStack.push(startNodeId);
                render();
                setTimeout(() => startAnimation(path), 500); 
            } else {
                startAnimation(path);
            }
        }

        /**
         * Procesa una lista de aristas para eliminar duplicados sem√°nticos.
         * Por ejemplo, si hay una relaci√≥n con un campo 'controller' y otra con un par√°metro
         * 'controller', priorizar√° y mantendr√° solo la del campo.
         * @param {Array<ProjectGraphEdge>} edges - La lista de aristas a procesar.
         * @param {Map<string, ProjectGraphNode>} nodeMap - El mapa global de nodos para obtener sus detalles.
         * @returns {Array<ProjectGraphEdge>} Una nueva lista de aristas sin duplicados visuales.
         */
        function getDeduplicatedRelationships(edges, nodeMap) {
            if (!edges || edges.length === 0) {
                return [];
            }

            const kindPriority = {
                'field': 1,
                'property': 1,
                'class': 2,
                'enum': 2,
                'method': 3,
                'function': 3,
                'constructor': 4,
                'parameter': 5,  // Parameters have the lowest priority
            };

            const relationshipGroups = new Map();

            edges.forEach(edge => {
                const sourceNode = nodeMap.get(edge.source);
                const targetNode = nodeMap.get(edge.target);

                if (!sourceNode || !targetNode) return; // Invalid edge

                const groupKey = `${edge.label}#${targetNode.label}`;

                const newEdgePriority = kindPriority[targetNode.kind] || 99; // 99 for undefined types

                const existingEdge = relationshipGroups.get(groupKey);

                if (!existingEdge) {
                   
                    relationshipGroups.set(groupKey, edge);
                } else {
                    const existingTargetNode = nodeMap.get(existingEdge.target);
                    const existingEdgePriority = kindPriority[existingTargetNode.kind] || 99;

                    if (newEdgePriority < existingEdgePriority) {
                        
                        relationshipGroups.set(groupKey, edge);
                    }
                }
            });

            return Array.from(relationshipGroups.values());
        }

        /**
         * Helper function for debugging: Analyzes a list of nodes,
         * counts the occurrences of each ID, and logs a message if there are duplicates.
         * @param {Array<ProjectGraphNode>} nodes - The list of nodes to analyze.
         * @param {string} contextMessage - A message to know where it's being called from.
         */
        function logNodeListDuplicates(nodes, contextMessage) {
            const idCounts = new Map();
            nodes.forEach(node => {
                if (!node || !node.id) return;
                idCounts.set(node.id, (idCounts.get(node.id) || 0) + 1);
            });

            const duplicates = [];
            idCounts.forEach((count, id) => {
                if (count > 1) {
                    const node = nodeMap.get(id);
                    duplicates.push(`${node ? node.label : id} (x${count})`);
                }
            });

            if (duplicates.length > 0) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[DEBUGGER] üî¥ DUPLICATES FOUND in  '${contextMessage}':`, duplicates.join(', ')] 
                });
            } else {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[DEBUGGER] ‚úÖ No duplicates in '${contextMessage}'. Total nodes: ${nodes.length}`] 
                });
            }
        }

        /**
         * Groups nodes by folder based on their file path. Extracts the folder
         * of each node from its 'file' property, organizing them into a map where the
         * key is the folder path and the value is an array of contained nodes.
         *
         * @param {Array<Object>} nodes - Array of nodes with a 'file' property
         * @returns {Map<string, Array>} Map from folders to arrays of nodes
         */
        function groupNodesByFolder(nodes) {
            const folderGroups = new Map();

            for (const node of nodes) {
                if (!node.file) continue;
                const pathParts = node.file.split('/');
                const folder = pathParts.length > 1 ? pathParts.slice(0, -1).join('/') : 'root';

                if (!folderGroups.has(folder)) {
                folderGroups.set(folder, []);
                }
                folderGroups.get(folder).push(node);
            }

            return folderGroups;
        }

        /**
         * Logs debug messages only when DEBUG_FIT is enabled. Tries to
         * use the VS Code API for logging, with a fallback to console.log if not
         * available. A utility function for conditional debugging.
         *
         * @param {...any} args - Arguments to log
         */
        function debugLog(...args) {
            if (!DEBUG_FIT) return;
            try { vscodeApi.postMessage({ command: 'log', args }); } catch (_) { console.log('[DEBUG]', ...args); }
        }

        /**
         * Draws a debug rectangle around the bounding box of an SVG layer
         * when DEBUG_FIT is enabled. Displays visual information of the content's
         * dimensions and position to help with layout debugging.
         *
         * @param {SVGElement} svg - Container SVG element
         * @param {SVGElement} layer - Layer whose bounding box to display
         * @param {string} color - Color of the debug rectangle (default: '#00BCD4')
         */
        function drawDebugBBox(svg, layer, color = '#00BCD4') {
            if (!DEBUG_FIT) return;
            const old = svg.querySelector('#__debug_bbox');
            if (old) old.remove();

            const bb = layer.getBBox();
            const g = createSvgElement('g', { id: '__debug_bbox' });
            const r = createSvgElement('rect', {
                x: bb.x, y: bb.y, width: Math.max(bb.width,1), height: Math.max(bb.height,1),
                fill: 'none', stroke: color, 'stroke-dasharray': '6 4', 'pointer-events': 'none'
            });
            const t = createSvgElement('text', {
                x: bb.x, y: bb.y - 6, 'font-size': 11, fill: color
            });
            t.textContent = `bbox x:${bb.x.toFixed(1)} y:${bb.y.toFixed(1)} w:${bb.width.toFixed(1)} h:${bb.height.toFixed(1)}`;
            g.appendChild(r); g.appendChild(t);
            layer.appendChild(g);
            }

        /**
         * Logs a sample of the current layout for debugging when DEBUG_FIT is
         * enabled. Extracts position information from up to 20 nodes of the layout
         * and logs it in a readable JSON format.
         *
         * @param {Object} layout - Layout object with a get() method
         * @param {string} tag - Identifying tag for the log
         */
        function logLayoutSnapshot(layout, tag = '') {
            if (!DEBUG_FIT) return;
            const out = [];
            if (layout && typeof layout.get === 'function') {
                let n = 0;
                for (const [id, _] of layout.map ?? []) {
                const p = layout.get(id);
                if (p) out.push({ id, ...p });
                if (++n >= 20) break;
                }
            }
            debugLog(`[Layout${tag}] sample:`, JSON.stringify(out.slice(0,8)));
        }
        
        /**
         * Shows the layer navigation slider by making it visible and updating
         * its position to the current layer. Used when entering views that
         * support navigation by layers or folder levels.
         */
        function showLayerSlider() {
            const slider = document.getElementById('layer-navigation-slider');
            if (slider) {
                slider.classList.add('visible');
                updateSliderPosition(currentLayerIndex);
            }
        }

        /**
         * Hides the layer navigation slider by removing its visibility class.
         * Used when navigating to views that do not require layer navigation.
         */
        function hideLayerSlider() {
            const slider = document.getElementById('layer-navigation-slider');
            if (slider) {
                slider.classList.remove('visible');
            }
        }

        /**
         * Updates the visual position of the slider and the active labels based
         * on the provided index. Calculates position percentages, handles index
         * limits, and synchronizes the visual state with the current navigation.
         *
         * @param {number} index - Index of the current layer/level
         * @param {number} totalLevels - Total number of levels (optional)
         * @returns {number} Safe index adjusted to the limits
         */
        function updateSliderPosition(index, totalLevels) {
            const thumb = document.getElementById('slider-thumb');
            const labels = document.querySelectorAll('.layer-label');
            
            if (!thumb) return;
            
            let maxIndex;
            if (typeof totalLevels === 'number' && totalLevels > 0) {
                maxIndex = totalLevels - 1;
            } else if (folderLevels && folderLevels.levels && folderLevels.levels.length > 0) {
                maxIndex = folderLevels.levels.length - 1;
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[updateSliderPosition] Using folderLevels.length: ${folderLevels.levels.length}`] 
                });
            } else if (labels.length > 0) {
                maxIndex = labels.length - 1;
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[updateSliderPosition] Using DOM labels.length: ${labels.length}`] 
                });
            }
            else {
                maxIndex = layerOrder.length - 1;
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[updateSliderPosition] Fallback to layerOrder.length: ${layerOrder.length}`] 
                });
            }
            
            const safeIndex = Math.max(0, Math.min(index, maxIndex));
            
            // Calculate position (0% to 100%)
            const position = maxIndex > 0 ? (safeIndex / maxIndex) * 100 : 0;
            
            // Apply the position
            thumb.style.left = `${position}%`;
            
            // Update active labels
            labels.forEach((label, i) => {
                label.classList.toggle('active', i === safeIndex);
            });
            
            return safeIndex;
        }

        /**
         * Navigates to a specific project layer by updating the current index
         * and the slider's position. Logs the navigation and applies visual changes
         * corresponding to the layer change.
         *
         * @param {number} layerIndex - Index of the target layer
         */
        function navigateToLayer(layerIndex) {
            if (layerIndex < 0 || layerIndex >= layerOrder.length) return;
            
            currentLayerIndex = layerIndex;
            updateSliderPosition(layerIndex);
            
            const layerName = layerOrder[layerIndex];
            
            vscodeApi.postMessage({ 
                command: 'log', 
                args: [`[Layer Navigation] Changing to layer: ${layerName}`] 
            });
        }

        /**
         * Calculates the layer index based on the mouse click position
         * on the slider track. Converts client coordinates to a percentage
         * of position and maps it to the range of available layers.
         *
         * @param {number} clientX - X-coordinate of the click
         * @param {HTMLElement} track - The slider's track element
         * @returns {number} The calculated layer index
         */
        function getLayerIndexFromPosition(clientX, track) {
            const rect = track.getBoundingClientRect();
            const x = clientX - rect.left;
            const percentage = Math.max(0, Math.min(1, x / rect.width));
            return Math.round(percentage * (layerOrder.length - 1));
        }

        /**
         * Initializes the full functionality of the layer/folder navigation slider.
         * Detects the appropriate navigation mode, sets up event listeners for
         * interaction (click, drag, keyboard), and handles both architectural layer
         * navigation and folder level navigation for the focused node.
         */
        function initializeLayerSlider() {
            const slider = document.getElementById('layer-navigation-slider');
            const thumb = document.getElementById('slider-thumb');
            const track = document.querySelector('.slider-track');
            const labels = document.querySelectorAll('.layer-label');
            
            if (!slider || !thumb || !track) return;


            const currentRoute = historyStack[historyStack.length - 1] || 'overview';
            const isFocusView = !currentRoute.startsWith('overview') && 
                                !currentRoute.startsWith('folders:') && 
                                currentRoute !== 'overview';

            let navigationMode = 'layers';

            if (isFocusView && focusedContainerId) {
                const focusNode = nodeMap.get(focusedContainerId);
                if (focusNode?.data?.fileUri) {

                    folderLevels = buildFolderLevelsFromNode(focusNode);
                    if (folderLevels && folderLevels.levels.length > 1) {
                        navigationMode = 'folders';
                        currentFolderLevel = 0; 

                        updateSliderForFolderMode(folderLevels);
                    }
                }
            }


            track.addEventListener('click', (e) => {
                if (isDragging) return;
                
                const rect = track.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percentage = Math.max(0, Math.min(1, x / rect.width));
                
                if (navigationMode === 'folders' && folderLevels) {
                    const levelIndex = Math.round(percentage * (folderLevels.levels.length - 1));
                    navigateToFolderLevel(levelIndex);
                } else {
                    const layerIndex = Math.round(percentage * (layerOrder.length - 1));
                    navigateToLayer(layerIndex);
                }
            });
            
            let startX = 0;
            let startLeft = 0;
            
            thumb.addEventListener('mousedown', (e) => {
                isDragging = true;
                thumb.classList.add('dragging');
                
                startX = e.clientX;
                const rect = track.getBoundingClientRect();
                
                if (navigationMode === 'folders') {
                    startLeft = (currentFolderLevel / (folderLevels.levels.length - 1)) * rect.width;
                } else {
                    startLeft = (currentLayerIndex / (layerOrder.length - 1)) * rect.width;
                }
                
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const rect = track.getBoundingClientRect();
                const deltaX = e.clientX - startX;
                const newX = startLeft + deltaX;
                const percentage = Math.max(0, Math.min(1, newX / rect.width));
                
                if (navigationMode === 'folders' && folderLevels) {
                    const levelIndex = Math.round(percentage * (folderLevels.levels.length - 1));
                    const exactPosition = percentage * 100;
                    thumb.style.left = `${exactPosition}%`;
                    
                    if (levelIndex !== currentFolderLevel) {
                        navigateToFolderLevel(levelIndex);
                    }
                } else {
                    const layerIndex = Math.round(percentage * (layerOrder.length - 1));
                    const exactPosition = percentage * 100;
                    thumb.style.left = `${exactPosition}%`;
                    
                    if (layerIndex !== currentLayerIndex) {
                        navigateToLayer(layerIndex);
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    thumb.classList.remove('dragging');
                    
                    if (navigationMode === 'folders') {
                        updateSliderPosition(currentFolderLevel);
                    } else {
                        updateSliderPosition(currentLayerIndex);
                    }
                }
            });
            
            document.addEventListener('keydown', (e) => {
                if (!slider.classList.contains('visible')) return;
                
                if (navigationMode === 'folders' && folderLevels) {
                    if (e.key === 'ArrowLeft' && currentFolderLevel > 0) {
                        navigateToFolderLevel(currentFolderLevel - 1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowRight' && currentFolderLevel < folderLevels.levels.length - 1) {
                        navigateToFolderLevel(currentFolderLevel + 1);
                        e.preventDefault();
                    }
                } else {
                    if (e.key === 'ArrowLeft' && currentLayerIndex > 0) {
                        navigateToLayer(currentLayerIndex - 1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowRight' && currentLayerIndex < layerOrder.length - 1) {
                        navigateToLayer(currentLayerIndex + 1);
                        e.preventDefault();
                    }
                }
            });
            
            thumb.addEventListener('dragstart', (e) => e.preventDefault());
            
            if (navigationMode === 'folders') {
                updateSliderPosition(0);
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[Slider] Folder mode activated with ${folderLevels.levels.length} levels`] 
                });
            } else {
                updateSliderPosition(0);
            }
        }

        /**
         * Builds a hierarchical structure of folder levels from a specific node.
         * Analyzes the file URI to create levels from the individual file up to
         * the project root, calculating metrics for each level including node count,
         * connections, cohesion, and architectural scope type.
         *
         * @param {Object} node - The node from which to build the folder levels
         * @returns {Object|null} Object with the level structure or null if not valid
         */
        function buildFolderLevelsFromNode(node) {
            if (!node?.data?.fileUri) return null;
            
            const fileUri = node.data.fileUri;
            const parts = fileUri.split('/');

            const libIndex = parts.indexOf('lib');
            if (libIndex === -1) return null;
            
            const relevantParts = parts.slice(libIndex);
            const fileName = relevantParts[relevantParts.length - 1];
            const folderParts = relevantParts.slice(0, -1);
            
            const levels = [];
            
            levels.push({
                name: node.label || fileName.replace('.dart', ''),
                depth: relevantParts.length,
                path: fileUri,
                type: 'file',
                nodeCount: 1, 
                description: `Clase ${node.label}`
            });
            
            if (folderParts.length > 1) {
                const immediateFolderName = folderParts[folderParts.length - 1];
                const immediateFolderPath = folderParts.join('/');

                const nodesInFolder = allGraphNodes.filter(n => {
                    return n.data?.fileUri && 
                        n.data.fileUri.includes(immediateFolderPath) &&
                        n.data.fileUri.split('/').length === relevantParts.length &&
                        !n.parent;
                }).length;
                
                levels.push({
                    name: immediateFolderName,
                    depth: folderParts.length,
                    path: immediateFolderPath,
                    type: 'folder',
                    nodeCount: nodesInFolder,
                    description: `${nodesInFolder} clases en ${immediateFolderName}`
                });
            }
            
            for (let i = folderParts.length - 2; i >= 0; i--) {
                const currentPath = folderParts.slice(0, i + 1).join('/');
                const currentName = folderParts[i];
                
                const nodesUnderPath = allGraphNodes.filter(n => {
                    return n.data?.fileUri && 
                        n.data.fileUri.startsWith(currentPath + '/') &&
                        !n.parent;
                }).length;
                
                let folderType = 'folder';
                let description = `${nodesUnderPath} classes`;
                
                if (currentName === 'features' || currentName === 'modules') {
                    folderType = 'features';
                    description = `${nodesUnderPath} classes in all features`;
                } else if (currentName === 'widgets' || currentName === 'components') {
                    folderType = 'widgets';
                    description = `${nodesUnderPath} UI components`;
                } else if (currentName === 'services' || currentName === 'providers') {
                    folderType = 'services';
                    description = `${nodesUnderPath} services`;
                } else if (currentName === 'models' || currentName === 'entities') {
                    folderType = 'models';
                    description = `${nodesUnderPath} data models`;
                } else if (currentName === 'src') {
                    folderType = 'source';
                    description = `C√≥digo fuente (${nodesUnderPath} clases)`;
                } else if (currentName === 'lib') {
                    folderType = 'root';
                    description = `Source code (${nodesUnderPath} classes)`;
                } else if (i === folderParts.length - 3 && folderParts[i - 1] === 'features') {
                    folderType = 'feature';
                    const subfolders = new Set();
                    allGraphNodes.forEach(n => {
                        if (n.data?.fileUri && n.data.fileUri.startsWith(currentPath + '/')) {
                            const subpath = n.data.fileUri.substring(currentPath.length + 1);
                            const firstFolder = subpath.split('/')[0];
                            if (firstFolder && !firstFolder.endsWith('.dart')) {
                                subfolders.add(firstFolder);
                            }
                        }
                    });
                    description = `Feature ${currentName} (${nodesUnderPath} classes, ${subfolders.size} folders)`;
                }
                
                levels.push({
                    name: currentName,
                    depth: i + 1,
                    path: currentPath,
                    type: folderType,
                    nodeCount: nodesUnderPath,
                    description: description
                });
            }
            
            levels.forEach((level, index) => {
                if (index === 0) {
                    const edges = allGraphEdges.filter(e => 
                        e.source === node.id || e.target === node.id
                    );
                    level.incomingConnections = edges.filter(e => e.target === node.id).length;
                    level.outgoingConnections = edges.filter(e => e.source === node.id).length;
                } else {
                    const nodesInLevel = allGraphNodes.filter(n => 
                        n.data?.fileUri && 
                        n.data.fileUri.startsWith(level.path + '/') &&
                        !n.parent
                    );
                    
                    const nodeIds = new Set(nodesInLevel.map(n => n.id));
                    
                    let internalConnections = 0;
                    let externalIncoming = 0;
                    let externalOutgoing = 0;
                    
                    allGraphEdges.forEach(edge => {
                        const sourceInLevel = nodeIds.has(getContainerId(edge.source));
                        const targetInLevel = nodeIds.has(getContainerId(edge.target));
                        
                        if (sourceInLevel && targetInLevel) {
                            internalConnections++;
                        } else if (!sourceInLevel && targetInLevel) {
                            externalIncoming++;
                        } else if (sourceInLevel && !targetInLevel) {
                            externalOutgoing++;
                        }
                    });
                    
                    level.internalConnections = internalConnections;
                    level.incomingConnections = externalIncoming;
                    level.outgoingConnections = externalOutgoing;
                    level.cohesion = internalConnections / Math.max(1, internalConnections + externalOutgoing);
                }
            });
            
            levels.forEach(level => {
                if (level.type === 'file') {
                    level.scope = 'specific';
                    level.scopeScore = 1; 
                } else {
                    const contents = folderContentIndex.get(level.path);
                    
                    if (contents && contents.subfolderCount > 0 && contents.fileCount <= 2) {
                        level.scope = 'architectural';
                        level.scopeScore = 3;
                    } else {
                        level.scope = 'local';
                        level.scopeScore = 2;
                    }
                }
            });
            
            vscodeApi.postMessage({ 
                command: 'log', 
                args: [
                    `[Folder Levels] Built ${levels.length} levels for ${node.label}:`,
                    levels.map(l => `  ${l.name} (${l.type}): ${l.nodeCount} nodes, ${l.description}`)
                ] 
            });
            
            return {
                currentNodeId: node.id,
                currentNodeLabel: node.label,
                levels: levels,
                totalLevels: levels.length,
                currentLevel: 0
            };
        }

        /**
         * Gets the relevant nodes and edges for a specific folder level.
         * Filters nodes by path, calculates connection statistics, applies display
         * limits based on the level type, and returns structured data
         * for rendering the level.
         *
         * @param {string} focusNodeId - ID of the focus node
         * @param {Object} level - Level object with folder information
         * @returns {Object} Level data with nodes, edges, and statistics
         */
        function getNodesAtFolderLevel(focusNodeId, level) {
            const focusNode = nodeMap.get(focusNodeId);
            if (!focusNode || !level) return { nodes: [], edges: [], stats: {} }; // Return empty stats
            
            const levelPath = level.path;
            const levelType = level.type;
            
            if (levelType === 'file') {
                const relevantEdges = allGraphEdges.filter(e =>
                getContainerId(e.source) === focusNodeId || getContainerId(e.target) === focusNodeId
                );
            
                const stats = {
                    totalNodesInLevel: 1,
                    displayedNodes: 1,
                    totalEdges: relevantEdges.length,
                    internalEdges: 0,
                    focusConnections: relevantEdges.length,
                    scope: 'specific'
                };

                return {
                    nodes: [focusNode],
                    edges: relevantEdges,
                    stats: stats,
                    level: level
                };
            }
            
            const nodesAtLevel = [];
            const relevantNodeIds = new Set();
            
            allGraphNodes.forEach(node => {
                if (!node.data?.fileUri || node.parent) return;

                const absoluteUri = node.data.fileUri;
            
                const relativeUri = absoluteUri.substring(absoluteUri.indexOf('lib'));

                const nodeFolder = relativeUri.substring(0, relativeUri.lastIndexOf('/'));
            
                if (nodeFolder === levelPath || nodeFolder.startsWith(levelPath + '/')) {
                nodesAtLevel.push(node);
                relevantNodeIds.add(node.id);
                }
            });
            
            const relevantEdges = [];
            const edgeMap = new Map(); 
            
            allGraphEdges.forEach(edge => {
                const sourceContainer = getContainerId(edge.source);
                const targetContainer = getContainerId(edge.target);
                
                
                const sourceInLevel = relevantNodeIds.has(sourceContainer);
                const targetInLevel = relevantNodeIds.has(targetContainer);
                const involvesFocus = sourceContainer === focusNodeId || targetContainer === focusNodeId;
                
                if (involvesFocus || (sourceInLevel && targetInLevel)) {
                    const key = `${sourceContainer}->${targetContainer}`;
                    
                    if (!edgeMap.has(key)) {
                        edgeMap.set(key, {
                            ...edge,
                            weight: 1,
                            isInternal: sourceInLevel && targetInLevel,
                            involvesFocus: involvesFocus
                        });
                    } else {
                        edgeMap.get(key).weight++;
                    }
                }
            });
            
            relevantEdges.push(...edgeMap.values());
            
            const connectedToFocus = new Set();
            relevantEdges.forEach(edge => {
                if (edge.involvesFocus) {
                    const otherId = edge.source === focusNodeId ? edge.target : edge.source;
                    connectedToFocus.add(getContainerId(otherId));
                }
            });
            
            nodesAtLevel.sort((a, b) => {
                if (a.id === focusNodeId) return -1;
                if (b.id === focusNodeId) return 1;
                
                const aConnected = connectedToFocus.has(a.id);
                const bConnected = connectedToFocus.has(b.id);
                if (aConnected && !bConnected) return -1;
                if (!aConnected && bConnected) return 1;
                
                const aDegree = (a.inDegree || 0) + (a.outDegree || 0);
                const bDegree = (b.inDegree || 0) + (b.outDegree || 0);
                return bDegree - aDegree;
            });
            
            const maxNodes = levelType === 'root' ? 20 : 
                            levelType === 'source' ? 30 : 
                            levelType === 'features' ? 25 : 50;
            
            const limitedNodes = nodesAtLevel.slice(0, maxNodes);
            
            if (limitedNodes.length < nodesAtLevel.length) {
                const limitedIds = new Set(limitedNodes.map(n => n.id));
                relevantEdges.filter(e => {
                    const sourceId = getContainerId(e.source);
                    const targetId = getContainerId(e.target);
                    return limitedIds.has(sourceId) && limitedIds.has(targetId);
                });
            }
            
            const stats = {
                totalNodesInLevel: nodesAtLevel.length,
                displayedNodes: limitedNodes.length,
                totalEdges: relevantEdges.length,
                internalEdges: relevantEdges.filter(e => e.isInternal).length,
                focusConnections: relevantEdges.filter(e => e.involvesFocus).length,
                scope: levelType === 'file' ? 'specific' :
                    levelType === 'folder' ? 'local' :
                    levelType === 'feature' ? 'module' :
                    levelType === 'features' ? 'architectural' : 'global'
            };
            
            vscodeApi.postMessage({ 
                command: 'log', 
                args: [
                    `[Folder Level] ${level.name}: ${stats.displayedNodes}/${stats.totalNodesInLevel} nodes, ${stats.totalEdges} edges`,
                    `  Scope: ${stats.scope}, Focus connections: ${stats.focusConnections}`
                ] 
            });
            
            return {
                nodes: limitedNodes,
                edges: relevantEdges,
                stats: stats,
                level: level
            };
        }

        /**
         * Updates the focus view to display a specific folder level.
         * Determines the appropriate layout type (radial vs. hierarchical) based on
         * the level's scope, renders nodes and connections, and handles navigation
         * between folders by creating navigable nodes when appropriate.
         *
         * @param {string} focusNodeId - ID of the focus node
         * @param {Object} level - The folder level to display
         */
        function updateFocusViewForFolderLevel(focusNodeId, level) {
            try {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[updateFocusViewForFolderLevel] Starting for level: ${level.name}, scope: ${level.scopeScore}`] 
                });

                const levelData = getNodesAtFolderLevel(focusNodeId, level);

                if (!levelData || !levelData.nodes || levelData.nodes.length === 0) {
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[updateFocusViewForFolderLevel] No data to display`] 
                    });
                    mainLayer.innerHTML = '';
                    return;
                }

                mainLayer.innerHTML = '';

                const edgeLayer = createSvgElement('g', { class: 'edge-layer' });
                const nodeLayer = createSvgElement('g', { class: 'node-layer' });

                mainLayer.appendChild(edgeLayer);
                mainLayer.appendChild(nodeLayer);

                const focusNode = nodeMap.get(focusNodeId);
                const { nodes: nodesAtLevel, edges: edgesAtLevel, stats } = levelData;

                let layout;

                if(level.scopeScore > 1 ){
                    const existingLegend = document.querySelector('.legend');
                    if (existingLegend) {
                        existingLegend.remove();
                    }
                }

                if (level.scopeScore <= 2 || level.viewType === 'file-cluster') {
                    
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[Layout] Using RADIAL layout for ${level.name}`] 
                    });

                    const nodesForDisplay = nodesAtLevel.map(node => {
                        const fileName = (node.data?.fileUri || node.label || 'unknown').split('/').pop().replace('.dart', '');
                        return {...node, label: fileName};
                    });

                    const centerNode = {
                        id: `center-label:${level.name}`,
                        label: level.name.toUpperCase(),
                        kind: 'folder-center'
                    };

                    const allNodesForLayout = [centerNode, ...nodesForDisplay];
                    layout = calculateRadialLayout(allNodesForLayout, centerNode.id);

                    allNodesForLayout.forEach(node => {
                        renderCollapsedContainer(node, layout);
                    });

                } else {
                    
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[Layout] Using HIERARCHICAL layout for ${level.name}`] 
                    });

                    const folderNodesMap = new Map();
                    const fileToFolderIdMap = new Map();

                    nodesAtLevel.forEach(node => {
                        if (!node.data?.fileUri) return;

                        const relativeUri = node.data.fileUri.substring(node.data.fileUri.indexOf('lib'));

                        if (relativeUri.startsWith(level.path + '/')) {
                            const subPath = relativeUri.substring(level.path.length + 1);
                            const directChildFolder = subPath.split('/')[0];

                            if (directChildFolder && !directChildFolder.endsWith('.dart')) {
                                const folderId = `folder:${level.path}/${directChildFolder}`;
                                
                                fileToFolderIdMap.set(node.id, folderId);
                                
                                if (!folderNodesMap.has(folderId)) {
                                    const folderNode = {
                                        id: folderId,
                                        label: directChildFolder,
                                        kind: 'group',
                                        folderPath: `${level.path}/${directChildFolder}`,
                                        parentLevel: level,
                                        focusNodeId: focusNodeId,
                                        canNavigateDown: true, 
                                        depth: level.depth + 1,
                                        isNavigableFolder: true 
                                    };
                                    
                                    vscodeApi.postMessage({ 
                                        command: 'log', 
                                        args: [`[FOLDER CREATION] üìÅ Creating navigable folder:`, 
                                            `  ID: ${folderId}`, 
                                            `  Label: ${directChildFolder}`, 
                                            `  Path: ${folderNode.folderPath}`, 
                                            `  canNavigateDown: ${folderNode.canNavigateDown}`] 
                                    });
                                    
                                    folderNodesMap.set(folderId, folderNode);
                                }
                            }
                        }
                    });

                    const nodesForLayout = Array.from(folderNodesMap.values());
                    
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[Layout] Created ${nodesForLayout.length} navigable folders`,
                            `Carpetas:`, nodesForLayout.map(n => `${n.label} (canNavigate: ${n.canNavigateDown})`)] 
                    });

                    const aggregatedEdges = new Map();

                    edgesAtLevel.forEach(edge => {
                        const sourceFolderId = fileToFolderIdMap.get(getContainerId(edge.source));
                        const targetFolderId = fileToFolderIdMap.get(getContainerId(edge.target));

                        if (sourceFolderId && targetFolderId && sourceFolderId !== targetFolderId) {
                            const key = `${sourceFolderId}->${targetFolderId}`;
                            if (!aggregatedEdges.has(key)) {
                                aggregatedEdges.set(key, {
                                    source: sourceFolderId,
                                    target: targetFolderId,
                                    weight: 0
                                });
                            }
                            aggregatedEdges.get(key).weight++;
                        }
                    });

                    const edgesForLayout = Array.from(aggregatedEdges.values());
                    layout = calculateColumnLayout(nodesForLayout, edgesForLayout);
                    
                    renderFolderEdgesHorizontal(edgesForLayout, layout, edgeLayer);

                    nodesForLayout.forEach(node => {
                        vscodeApi.postMessage({ 
                            command: 'log', 
                            args: [`[RENDER DECISION] üé® Evaluating node: ${node.label}`, 
                                `  canNavigateDown: ${node.canNavigateDown}`, 
                                `  folderPath: ${node.folderPath}`, 
                                `  isNavigableFolder: ${node.isNavigableFolder}`] 
                        });

                        if (node.canNavigateDown && node.folderPath) {
                            vscodeApi.postMessage({ 
                                command: 'log', 
                                args: [`[RENDER DECISION] ‚úÖ Using renderNavigableFolderContainer for: ${node.label}`] 
                            });
                            renderNavigableFolderContainer(node, layout);
                        } else {
                            vscodeApi.postMessage({ 
                                command: 'log', 
                                args: [`[RENDER DECISION] ‚ùå Using renderCollapsedContainer for: ${node.label}`] 
                            });
                            renderCollapsedContainer(node, layout);
                        }
                    });
                }

                autoFit(svg, mainLayer);

                vscodeApi.postMessage({
                    command: 'log',
                    args: [
                        `[Folder Level View] Completed for: ${level.name}`,
                        ` View type: ${level.viewType || 'default'}`,
                        ` Depth: ${level.depth}`,
                        ` Nodes: ${stats.displayedNodes}/${stats.totalNodesInLevel}`,
                        ` Connections: ${edgesAtLevel.length} edges`
                    ]
                });

            } catch (e) {
                vscodeApi.postMessage({
                    command: 'log',
                    args: [`[ERROR] updateFocusViewForFolderLevel: ${e.message}`, e.stack]
                });
            }
        }

        /**
         * Renders a central label node for folder views. Creates a
         * circle with centered text that acts as a visual focal point in radial
         * layouts, showing the current folder name or context.
         *
         * @param {Object} node - The central label node
         * @param {Object} layout - Layout object with positions
         * @returns {SVGElement|null} The central node's SVG element or null
         */
        function renderCenterLabelNode(node, layout) {
            const nodeLayout = layout.get(node.id);
            if (!nodeLayout) return null;

            const group = createSvgElement('g', {
                'transform': `translate(${nodeLayout.x}, ${nodeLayout.y})`,
                'class': 'node node-folder-label'
            });

            const circle = createSvgElement('circle', {
                'r': 60, 
                'fill': 'var(--vscode-editor-background)',
                'stroke': '#6f42c1', 
                'stroke-width': 2
            });

            const text = createSvgElement('text', {
                'text-anchor': 'middle',
                'dominant-baseline': 'middle',
                'fill': 'var(--vscode-editor-foreground)',
                'font-size': '14px',
                'font-weight': 'bold'
            });
            text.textContent = node.label;

            group.appendChild(circle);
            group.appendChild(text);
            mainLayer.querySelector('.node-layer').appendChild(group);
            return group;
        }

        /**
         * Calculates a graph-based layout to organize nodes into levels according
         * to their connections. Places the focus node in the center and distributes
         * connected nodes in concentric levels based on their connection
         * distance from the focus.
         *
         * @param {Array<Object>} nodes - Array of nodes to position
         * @param {Array<Object>} edges - Array of connecting edges
         * @param {string} focusId - ID of the central focus node
         * @returns {Map} A map with node positions
         */
        function calculateGraphLayout(nodes, edges, focusId) {
            const layout = new Map();
            const nodeWidth = 200;
            const nodeHeight = 40;
            
            const focusNode = nodes.find(n => n.id === focusId);
            if (!focusNode) return layout;
            
            layout.set(focusId, {
                x: 0,
                y: 0,
                width: nodeWidth + 40,
                height: nodeHeight + 20
            });
            
            const graph = new Map();
            nodes.forEach(n => graph.set(n.id, { incoming: [], outgoing: [] }));
            
            edges.forEach(edge => {
                const sourceId = getContainerId(edge.source);
                const targetId = getContainerId(edge.target);
                
                if (graph.has(sourceId)) {
                    graph.get(sourceId).outgoing.push(targetId);
                }
                if (graph.has(targetId)) {
                    graph.get(targetId).incoming.push(sourceId);
                }
            });
            
            const levels = new Map();
            const visited = new Set();
            const queue = [[focusId, 0]];
            
            while (queue.length > 0) {
                const [nodeId, level] = queue.shift();
                if (visited.has(nodeId)) continue;
                
                visited.add(nodeId);
                if (!levels.has(level)) levels.set(level, []);
                levels.get(level).push(nodeId);
                
                const nodeGraph = graph.get(nodeId);
                if (nodeGraph) {
                    [...nodeGraph.incoming, ...nodeGraph.outgoing].forEach(neighborId => {
                        if (!visited.has(neighborId)) {
                            queue.push([neighborId, level + 1]);
                        }
                    });
                }
            }
            
            const levelSpacing = 250;
            const nodeSpacing = 80;
            
            levels.forEach((nodeIds, level) => {
                if (level === 0) return; 
                
                const nodesInLevel = nodeIds.filter(id => id !== focusId);
                const totalHeight = nodesInLevel.length * nodeSpacing;
                let currentY = -totalHeight / 2;
                
                nodesInLevel.forEach(nodeId => {
                    const angle = (level - 1) * (Math.PI / 6); 
                    const radius = level * levelSpacing;
                    
                    layout.set(nodeId, {
                        x: radius * Math.cos(angle),
                        y: currentY + nodeHeight / 2,
                        width: nodeWidth,
                        height: nodeHeight
                    });
                    
                    currentY += nodeSpacing;
                });
            });
            
            return layout;
        }

        /**
         * Calculates a radial layout using physics-based force simulation. Applies
         * gravity forces toward the center, repulsion between nodes to avoid
         * overlap, and stabilization iterations to create a uniform distribution
         * around the fixed central node.
         *
         * @param {Array<Object>} nodes - Array of nodes to position
         * @param {string} focusId - ID of the fixed central node
         * @returns {Map} A map with final node positions
         */
        function calculateRadialLayout(nodes, focusId) {
            const layout = new Map();
            const nodeWidth = 180;
            const nodeHeight = 40;

            const iterations = 250;     // More iterations = more stable result
            const gravity = 0.0696;       // Attraction force towards the center. HIGHER = MORE COMPACT.
            const repulsion = 0.2;      // Pushing force to avoid collisions.
            const padding = 10;         // Minimum space between nodes.


            nodes.forEach(node => {
                node.x = (Math.random() - 0.5) * 50;
                node.y = (Math.random() - 0.5) * 50;
                node.vx = 0;
                node.vy = 0;
            });

            
            for (let i = 0; i < iterations; i++) {
                nodes.forEach(nodeA => {
                   
                    if (nodeA.id !== focusId) {
                        nodeA.vx -= nodeA.x * gravity;
                        nodeA.vy -= nodeA.y * gravity;
                    }

                  
                    nodes.forEach(nodeB => {
                        if (nodeA.id === nodeB.id) return;

                        const dx = nodeA.x - nodeB.x;
                        const dy = nodeA.y - nodeB.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Minimum distance to avoid overlap (considering size and padding)
                        const minDistance = (nodeWidth / 2) + (nodeWidth / 2) + padding;

                        if (distance < minDistance) {
                            
                            const force = (minDistance - distance) * repulsion;
                            const angle = Math.atan2(dy, dx);
                            
                            nodeA.vx += Math.cos(angle) * force;
                            nodeA.vy += Math.sin(angle) * force;
                            
                            nodeB.vx -= Math.cos(angle) * force;
                            nodeB.vy -= Math.sin(angle) * force;
                        }
                    });
                });
                
                nodes.forEach(node => {
                    if (node.id === focusId) {
                        node.x = 0;
                        node.y = 0;
                        node.vx = 0;
                        node.vy = 0;
                    } else {
                        node.x += node.vx;
                        node.y += node.vy;
                        node.vx *= 0.95; 
                        node.vy *= 0.95;
                    }
                });
            }

            nodes.forEach(node => {
                layout.set(node.id, {
                    x: node.x, y: node.y, width: nodeWidth, height: nodeHeight
                });
            });

            return layout;
        }

        /**
         * Analyzes all nodes and creates an index of the content of each folder.
         * Returns a Map where the key is the folder path and the value is { fileCount, subfolderCount }.
         */
        function buildFolderContentIndex() {
            const index = new Map();

            allGraphNodes.forEach(node => {
                if (!node.data?.fileUri) return;

                const pathParts = node.data.fileUri.split('/');
                const libIndex = pathParts.indexOf('lib');
                if (libIndex === -1) return;

                const folderPathParts = pathParts.slice(libIndex, pathParts.length - 1);

                // Traverse the folder hierarchy upwards
                for (let i = 1; i <= folderPathParts.length; i++) {
                    const currentPath = folderPathParts.slice(0, i).join('/');
                    if (!index.has(currentPath)) {
                        index.set(currentPath, { fileCount: 0, subfolderCount: 0, subfolders: new Set() });
                    }

                    if (i === folderPathParts.length) {
                        index.get(currentPath).fileCount++;
                    }
                    else if (i < folderPathParts.length) {
                        const subfolder = folderPathParts[i];
                        if (!index.get(currentPath).subfolders.has(subfolder)) {
                            index.get(currentPath).subfolders.add(subfolder);
                            index.get(currentPath).subfolderCount++;
                        }
                    }
                }
            });
            return index;
        }

        /**
         * Renders a navigable folder container with full interactive functionality.
         * Creates the visual representation using pills, adds navigation icons, sets up
         * event listeners for click and hover, and applies visual effects. Allows direct
         * navigation to subfolders when the node has navigation capability enabled.
         *
         * @param {Object} node - Folder node with navigation properties
         * @param {Object} layout - Layout object with node positions
         * @returns {SVGElement|null} The navigable container's SVG element or null if there is an error
         */
        function renderNavigableFolderContainer(node, layout) {
            vscodeApi.postMessage({ 
                command: 'log', 
                args: [`[renderNavigableFolderContainer] üé® Drawing NAVIGABLE FOLDER: ${node.label} (path: ${node.folderPath})`] 
            });
            
            try {
                const nodeLayout = layout.get(node.id);
                if (!nodeLayout) {
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[renderNavigableFolderContainer] ‚ùå No layout found for: ${node.id}`] 
                    });
                    return null;
                }

                const group = createSvgElement('g', {
                    'transform': `translate(${nodeLayout.x}, ${nodeLayout.y})`,
                    'class': 'node folder-node navigable-folder',
                    'data-id': node.id,
                    'data-folder-path': node.folderPath || '',
                    'data-can-navigate': node.canNavigateDown || false
                });
                
                const pillResult = createPillVisual(node, nodeLayout.width);
                if (!pillResult) {
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[renderNavigableFolderContainer] ‚ùå Error creating visual pill for: ${node.label}`] 
                    });
                    return null;
                }

                const { pillGroup, pillWidth, pillHeight } = pillResult;
                group.appendChild(pillGroup);

                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[renderNavigableFolderContainer] ‚úÖ Visual pill added: ${node.label}`] 
                });

                if (node.canNavigateDown && node.folderPath) {
                    group.style.cursor = 'pointer';
                    
                    const navigationIcon = createSvgElement('text', {
                        'x': (pillWidth / 2) - 15,
                        'y': 5,
                        'font-size': '12px',
                        'fill': '#6f42c1',
                        'text-anchor': 'middle',
                        'dominant-baseline': 'middle',
                        'pointer-events': 'none'
                    });
                    //navigationIcon.textContent = 'üìÅ';
                    group.appendChild(navigationIcon);

                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[renderNavigableFolderContainer] ‚úÖ Navigable icon added: ${node.label}`] 
                    });

                    group.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        
                        vscodeApi.postMessage({ 
                            command: 'log', 
                            args: [`[FOLDER CLICK] üñ±Ô∏è Folder clicked DIRECTLY: ${node.label}`, 
                                `Path: ${node.folderPath}`, 
                                `Focus: ${node.focusNodeId}`] 
                        });
                        
                        navigateToSubfolderDirect(node);
                    }, true);

                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[renderNavigableFolderContainer] ‚úÖ Event listener added: ${node.label}`] 
                    });

                    // Hover effect
                    group.addEventListener('mouseenter', () => {
                        group.style.transform = `translate(${nodeLayout.x}, ${nodeLayout.y}) scale(1.05)`;
                        group.style.filter = 'drop-shadow(0 4px 8px rgba(111, 66, 193, 0.3))';
                    });

                    group.addEventListener('mouseleave', () => {
                        group.style.transform = `translate(${nodeLayout.x}, ${nodeLayout.y}) scale(1)`;
                        group.style.filter = '';
                    });
                }

                const nodeLayer = mainLayer.querySelector('.node-layer');
                if (nodeLayer) {
                    nodeLayer.appendChild(group);
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[renderNavigableFolderContainer] ‚úÖ Navigable folder added to DOM ${node.label}`] 
                    });
                } else {
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[renderNavigableFolderContainer] ‚ùå .node-layer not found`] 
                    });
                }
                
                return group;

            } catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[WebView-ERROR] Failure in renderNavigableFolderContainer: ${e.message}`, e.stack] 
                });
                return null;
            }
        }

        /**
         * Navigates directly to a specific subfolder by replacing the current level
         * in the navigation hierarchy. Creates a new dynamic level, updates the
         * folderLevels structure by inserting the level in the appropriate position,
         * and updates the corresponding view and slider.
         *
         * @param {Object} folderNode - Folder node with navigation information
         */
        function navigateToSubfolderDirect(folderNode) {
            try {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[Direct Navigation] Navigating DIRECTLY to: ${folderNode.folderPath}`] 
                });

                const newLevel = createDynamicLevel(folderNode.folderPath, folderNode.focusNodeId);
                
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[Direct Navigation] New level created: ${newLevel.name}, scopeScore: ${newLevel.scopeScore}, viewType: ${newLevel.viewType}`] 
                });

                if (!folderLevels) {
                    const focusNode = nodeMap.get(folderNode.focusNodeId);
                    if (focusNode) {
                        folderLevels = buildFolderLevelsFromNode(focusNode);
                        currentFolderLevel = 0;
                    } else {
                        folderLevels = {
                            currentNodeId: folderNode.focusNodeId,
                            currentNodeLabel: 'Unknown',
                            levels: [],
                            totalLevels: 0,
                            currentLevel: 0
                        };
                        currentFolderLevel = 0;
                    }
                }

                if (folderLevels && folderLevels.levels) {
                   if (currentFolderLevel > 0) {
                        folderLevels.levels.splice(currentFolderLevel - 1, 1);
                    }
                    
                    folderLevels.levels.splice(currentFolderLevel - 1, 0, newLevel);
                    
                    currentFolderLevel = currentFolderLevel - 1;
                    
                    vscodeApi.postMessage({ 
                        command: 'log', 
                        args: [`[Direct Navigation] Level REPLACED at index: ${currentFolderLevel}`,
                            `Total levels: ${folderLevels.levels.length}`,
                            `Sequence: ${folderLevels.levels.map(l => l.name).join(' ‚Üí ')}`] 
                    });
                    
                    if (typeof updateSliderForFolderMode === 'function') {
                        updateSliderForFolderMode(folderLevels);
                        updateSliderPosition(currentFolderLevel, folderLevels.levels.length);
                    }
                }

                updateFocusViewForFolderLevel(folderNode.focusNodeId, newLevel);

            } catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[ERROR] navigateToSubfolderDirect: ${e.message}`, e.stack] 
                });
            }
        }

        /**
         * Navigates to a subfolder by adding a new level to the existing hierarchy.
         * Searches for existing levels to avoid duplication, inserts the new level
         * at the end of the current sequence, and updates all navigation including
         * the slider and focus view.
         *
         * @param {Object} folderNode - The target folder node
         */
        function navigateToSubfolder(folderNode) {
            try {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[Folder Navigation] Navigating to: ${folderNode.folderPath}`] 
                });

                const newLevel = createDynamicLevel(folderNode.folderPath, folderNode.focusNodeId);
                
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[Folder Navigation] New level created: ${newLevel.name}, scopeScore: ${newLevel.scopeScore}`] 
                });

                if (folderLevels) {
                    const existingLevelIndex = folderLevels.levels.findIndex(level => 
                        level.path === folderNode.folderPath
                    );
                    
                    if (existingLevelIndex !== -1) {
                        currentFolderLevel = existingLevelIndex;
                        updateSliderPosition(currentFolderLevel, folderLevels.levels.length);
                    } else {
                        const insertIndex = currentFolderLevel + 1;
                        
                        folderLevels.levels.splice(insertIndex);
                        
                        folderLevels.levels.push(newLevel);
                        currentFolderLevel = folderLevels.levels.length - 1;
                        
                        updateSliderPosition(currentFolderLevel, folderLevels.levels.length);
                        
                        updateSliderForFolderMode(folderLevels);
                    }
                } else {
                    const focusNode = nodeMap.get(folderNode.focusNodeId);
                    folderLevels = buildFolderLevelsFromNode(focusNode);
                    
                    folderLevels.levels.push(newLevel);
                    currentFolderLevel = folderLevels.levels.length - 1;
                    
                    updateSliderForFolderMode(folderLevels);
                    updateSliderPosition(currentFolderLevel, folderLevels.levels.length);
                }

                updateFocusViewForFolderLevel(folderNode.focusNodeId, newLevel);

            } catch (e) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[ERROR] navigateToSubfolder: ${e.message}`, e.stack] 
                });
            }
        }

        /**
         * Dynamically creates a folder level by analyzing the directory content.
         * Examines direct files and subfolders, determines the appropriate view type
         * (file-cluster, mixed, folder-hierarchy), calculates a scope score, and generates
         * a detailed description of the level for navigation.
         *
         * @param {string} folderPath - The folder path
         * @param {string} focusNodeId - ID of the focus node
         * @returns {Object} A level object with complete metadata
         */
        function createDynamicLevel(folderPath, focusNodeId) {
            const pathParts = folderPath.split('/');
            const folderName = pathParts[pathParts.length - 1];
            
            let totalNodes = 0;
            let directFiles = 0;
            let hasSubfolders = false;
            const subfolders = new Set();
            
            allGraphNodes.forEach(n => {
                if (!n.data?.fileUri || n.parent) return false;
                const relativeUri = n.data.fileUri.substring(n.data.fileUri.indexOf('lib'));
                
                if (relativeUri.startsWith(folderPath + '/')) {
                    totalNodes++;
                    
                    const subPath = relativeUri.substring(folderPath.length + 1);
                    const parts = subPath.split('/');
                    
                    if (parts.length === 1) {
                        directFiles++;
                    } else {
                        hasSubfolders = true;
                        subfolders.add(parts[0]);
                    }
                }
            });

            let scopeScore;
            let viewType;
            
            if (directFiles > 0 && !hasSubfolders) {
                scopeScore = 1;
                viewType = 'file-cluster';
            } else if (directFiles > 0 && hasSubfolders) {
                
                scopeScore = 2;
                viewType = 'mixed';
            } else if (!directFiles && hasSubfolders) {
                scopeScore = 3;
                viewType = 'folder-hierarchy';
            } else {
                scopeScore = 1;
                viewType = 'empty';
            }

            const level = {
                name: folderName,
                path: folderPath,
                depth: pathParts.length,
                type: 'folder',
                nodeCount: totalNodes,
                directFiles: directFiles,
                subfolderCount: subfolders.size,
                scopeScore: scopeScore,
                viewType: viewType,
                description: `${totalNodes} classes, ${directFiles} direct files, ${subfolders.size} subfolders`
            };

            vscodeApi.postMessage({ 
                command: 'log', 
                args: [
                    `[Dynamic Level] ${folderName}:`,
                    `  Path: ${folderPath}`,
                    `  Total nodes: ${totalNodes}`,
                    `  Direct files: ${directFiles}`,
                    `  Subfolders: ${subfolders.size}`,
                    `  Scope score: ${scopeScore}`,
                    `  View type: ${viewType}`
                ] 
            });

            return level;
        }

        
        /**
         * Updates the slider for folder navigation mode. Regenerates the
         * slider labels based on folder levels, applies appropriate icons,
         * configures informative tooltips, and updates the visual gradient
         * of the slider track.
         *
         * @param {Object} folderLevels - The folder levels structure
         */
        function updateSliderForFolderMode(folderLevels) {
            const slider = document.getElementById('layer-navigation-slider');
            if (!slider || !folderLevels) return;
            
            const labelsContainer = slider.querySelector('.layer-labels');
            if (!labelsContainer) return;
            
            vscodeApi.postMessage({ 
                command: 'log', 
                args: [`[Slider Update] Updating with ${folderLevels.levels.length} levels`] 
            });
            
            labelsContainer.innerHTML = '';
            
            folderLevels.levels.forEach((level, index) => {
                const label = document.createElement('span');
                label.className = 'layer-label';
                label.dataset.level = index;
                
                const icon = getFolderLevelIcon(index, folderLevels.levels.length);
                const displayName = truncateFolderName(level.name, 12);
                
                label.innerHTML = `${icon} ${displayName}`;
                label.title = `${level.path} - ${level.description || ''}`;
                
                labelsContainer.appendChild(label);
                
                label.addEventListener('click', (e) => {
                    e.stopPropagation();
                    navigateToFolderLevel(index);
                });
            });

            updateLabelColors(currentFolderLevel);
            
            updateTrackGradient(folderLevels.levels.length);
        }

        /**
         * Updates the colors and styles of the slider labels according to the active
         * level. Applies emphasis styles to the current level and dimmed styles to
         * inactive levels for a clear visual indication of position.
         *
         * @param {number} activeIndex - The index of the active level
         */
        function updateLabelColors(activeIndex) {
            document.querySelectorAll('.layer-label').forEach((label, index) => {
                label.classList.remove('active');
                label.style.fontWeight = '';
                
                if (index === activeIndex) {
                    label.classList.add('active');
                    label.style.fontWeight = 'bold';
                    label.style.color = '#ffffff';
                } else {
                    label.style.color = '#6f42c1';
                }
            });
        }
        
        /**
         * Gets the appropriate icon for a folder level based on its position
         * in the hierarchy. Assigns specific icons for the most specific,
         * most general, and intermediate levels for intuitive visual representation.
         *
         * @param {number} index - The level's index
         * @param {number} totalLevels - The total number of levels
         * @returns {string} The appropriate icon emoji
         */
        function getFolderLevelIcon(index, totalLevels) {
            if (index === 0) return 'üí°'; 
            if (index === totalLevels - 1) return 'üåç'; 
            if (index === 1) return 'üå±'; 
            return 'üèûÔ∏è'; 
        }
            
        /**
         * Truncates long folder names for display on the slider. Adds
         * an ellipsis when the name exceeds the maximum allowed length
         * to maintain readability in the interface.
         *
         * @param {string} name - The original folder name
         * @param {number} maxLength - The maximum allowed length
         * @returns {string} The truncated name if necessary
         */
        function truncateFolderName(name, maxLength) {
            if (name.length <= maxLength) return name;
            return name.substring(0, maxLength - 3) + '...';
        }

        /**
         * Updates the background gradient of the slider track to visually represent
         * the progression from specific to general levels.
         * Uses colors ranging from deep purple to light gray.
         *
         * @param {number} levelCount - The total number of levels
         */
        function updateTrackGradient(levelCount) {
            const track = document.querySelector('.slider-track');
            if (!track) return;
            
            // Gradiente desde espec√≠fico (morado) hasta general (gris)
            const gradient = `linear-gradient(90deg, 
                #6f42c1 0%,           /* Current/specific level */
                #8b5fc7 25%,          /* Immediate folder */
                #a78bfa 50%,          /* Feature/Module */
                #c4b5fd 75%,          /* Structure */
                #e9d5ff 100%          /* Root */
            )`;
            
            track.style.background = gradient;
        }
         
        /**
         * Navigates to a specific folder level in the hierarchy. Updates the
         * current index, synchronizes the slider position, updates label colors,
         * and renders the appropriate view based on the level type
         * (original focus vs. folder view).
         *
         * @param {number} levelIndex - Index of the target level
         */
        function navigateToFolderLevel(levelIndex) {
            if (!folderLevels || levelIndex < 0 || levelIndex >= folderLevels.levels.length) {
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[Navigation] Invalid index: ${levelIndex}`] 
                });
                return;
            }

            currentFolderLevel = levelIndex;
            updateSliderPosition(levelIndex, folderLevels.levels.length);

            updateLabelColors(levelIndex);

            const level = folderLevels.levels[levelIndex];
            const focusNodeId = folderLevels.currentNodeId;

            vscodeApi.postMessage({ 
                command: 'log', 
                args: [`[Slider Navigation] Navigating to level ${levelIndex}: ${level.name}, focusNodeId: ${focusNodeId}`] 
            });

            if (levelIndex === 0) {
                // Nivel m√°s espec√≠fico: vista de foco original
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[Slider Navigation] Rendering original focus view`] 
                });
                renderFocusView(focusNodeId, focusNodeId);
            } else {
                // Otros niveles: vista de carpetas
                vscodeApi.postMessage({ 
                    command: 'log', 
                    args: [`[Slider Navigation] Rendering folder view for level: ${level.name}`] 
                });
                updateFocusViewForFolderLevel(focusNodeId, level);
            }
        }
        
        /**
         * Sets up full zoom and pan functionality for an SVG element.
         * Implements mouse drag for panning, mouse scroll for zooming,
         * and handling of SVG matrix transformations for smooth diagram
         * navigation.
         *
         * @param {SVGElement} svg - The container SVG element
         * @param {SVGElement} layer - The content layer to transform
         */
        function setupZoomPan(svg, layer) {
            let pan = false, startX, startY, startMatrix;
            svg.addEventListener('mousedown', (e) => {
                if(e.target !== svg) return; 
                pan = true;
                startX = e.clientX;
                startY = e.clientY;
                const transform = layer.transform.baseVal.consolidate()?.matrix || svg.createSVGMatrix();
                startMatrix = [transform.a, transform.b, transform.c, transform.d, transform.e, transform.f];
            });
            svg.addEventListener('mousemove', (e) => {
                if (!pan) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                layer.setAttribute('transform', `matrix(${startMatrix[0]} ${startMatrix[1]} ${startMatrix[2]} ${startMatrix[3]} ${startMatrix[4] + dx} ${startMatrix[5] + dy})`);
            });
            window.addEventListener('mouseup', () => { pan = false; });
            svg.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scaleAmount = e.deltaY > 0 ? 0.9 : 1.1; // Zoom out/in
                const transform = layer.transform.baseVal.consolidate()?.matrix || svg.createSVGMatrix();
                let newMatrix = svg.createSVGMatrix()
                    .translate(e.offsetX, e.offsetY)
                    .scale(scaleAmount)
                    .translate(-e.offsetX, -e.offsetY)
                    .multiply(transform);
                layer.setAttribute('transform', `matrix(${newMatrix.a} ${newMatrix.b} ${newMatrix.c} ${newMatrix.d} ${newMatrix.e} ${newMatrix.f})`);
            });
        }
    })();

    

  </script>

</body>
</html>